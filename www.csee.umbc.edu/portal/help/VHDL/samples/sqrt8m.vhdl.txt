-- sqrt8m.vhdl  unsigned integer sqrt 8-bits computing unsigned integer 4-bits
--              sqrt(00000100) = 0010   sqrt(4)=2
--              sqrt(01000000) = 1000   sqrt(64)=8
--  modification of sqrt8.vhdl with specialized circuits

library IEEE;
use IEEE.std_logic_1164.all;

entity Sm is  -- subtractor multiplexor 
  port ( x  : in  std_logic;
         y  : in  std_logic;
         b  : in  std_logic;
         u  : in  std_logic;
         d  : out std_logic;
         bo : out std_logic);
end Sm;

architecture circuits of Sm is
  signal t011, t111, t010, t001, t100, td : std_logic;
begin  -- circuits of Sm
  t011 <= (not x) and y and b;
  t111 <= x and y and b;
  t010 <= (not x) and y and (not b);
  t001 <= (not x) and (not y) and b;
  t100 <= x and (not y) and (not b);
  bo   <= t011 or t111 or t010 or t001;
  td   <= t100 or t001 or t010 or t111;
  d    <= td when u='1' else x;  
end architecture circuits;  -- of Sm

library IEEE;
use IEEE.std_logic_1164.all;

entity Sb is 
  port ( x  : in  std_logic;
         y  : in  std_logic;
         b  : in  std_logic;
         bo : out std_logic);
end Sb;

architecture circuits of Sb is
  signal t011, t111, t010, t001 : std_logic;
begin  -- circuits of Sb
  t011 <= (not x) and y and b;
  t111 <= x and y and b;
  t010 <= (not x) and y and (not b);
  t001 <= (not x) and (not y) and b;
  bo   <= t011 or t111 or t010 or t001;
end architecture circuits;  -- of Sb


library IEEE;
use IEEE.std_logic_1164.all;

entity S1 is  -- subtractor multiplexor 
  port ( x  : in  std_logic;
         b  : in  std_logic;
         u  : in  std_logic;
         d  : out std_logic;
         bo : out std_logic);
end S1;

architecture circuits of S1 is
  signal t100, t001, td : std_logic;
begin  -- circuits of S1
  t001 <= (not x) and b;
  t100 <= x and (not b);
  bo   <= t001;
  td   <= t100 or t001;
  d    <= td when u='1' else x;  
end architecture circuits;  -- of S1

library IEEE;
use IEEE.std_logic_1164.all;

entity S0 is  
  port ( x  : in  std_logic;
         u  : in  std_logic;
         d  : out std_logic;
         bo : out std_logic);
end S0;

architecture circuits of S0 is
begin  -- circuits of S0
  bo   <= not x;
  d    <= not x when u='1' else x;  
end architecture circuits;  -- of S0

library IEEE;
use IEEE.std_logic_1164.all;

entity Sn is  -- subtractor multiplexor 
  port ( x  : in  std_logic;
         b  : in  std_logic;
         bo : out std_logic);
end Sn;

architecture circuits of Sn is
begin  -- circuits of Sn
  bo <= (not x) nand b;  -- complemented
end architecture circuits;  -- of Sn

library IEEE;
use IEEE.std_logic_1164.all;

entity S0b is  
  port ( x  : in  std_logic;
         bo : out std_logic);
end S0b;

architecture circuits of S0b is
begin  -- circuits of S0b
  bo <= not x;
end architecture circuits;  -- of S0b

library IEEE;
use IEEE.std_logic_1164.all;

entity S1b is  
  port ( x  : in  std_logic;
         b  : in  std_logic;
         bo : out std_logic);
end S1b;

architecture circuits of S1b is
begin  -- circuits of S1b
  bo <= (not x) and b;
end architecture circuits;  -- of S1b

library IEEE;
use IEEE.std_logic_1164.all;

entity psqrt is
  port ( P : in  std_logic_vector(7 downto 0);
         U : out std_logic_vector(3 downto 0));
end psqrt;

architecture circuits of psqrt is
  signal b00, b01, b02, b03, b04, b05 : std_logic;  
  signal x12, x13, x14, x15 : std_logic;  
  signal b12, b13, b14, b15, b16 : std_logic;  
  signal x24, x25, x26 : std_logic;  
  signal b24, b25, b26, b27 : std_logic;  
  signal x36, x37, bxx : std_logic;  
  signal b36, b37 : std_logic;  
begin  -- circuits of psqrt
  --                            x     y    b    u    d    bo
  s36: entity work.S0  port map(P(6),           b37, x36, b36);
  s37: entity work.S1  port map(P(7),      b36, b37, x37, bxx);
  b37 <= not bxx;

  s24: entity work.S0  port map(P(4),           b27, x24, b24);
  s25: entity work.S1  port map(P(5),      b24, b27, x25, b25);
  s26: entity work.Sm  port map(x36 , b37, b25, b27, x26, b26);
  s27: entity work.Sn  port map(x37 ,      b26,           b27);

  s12: entity work.S0  port map(P(2),           b16, x12, b12);
  s13: entity work.S1  port map(P(3),      b12, b16, x13, b13);
  s14: entity work.Sm  port map(x24 , b27, b13, b16, x14, b14);
  s15: entity work.Sm  port map(x25 , b37, b14, b16, x15, b15);
  s16: entity work.Sn  port map(x26 ,      b15,           b16);

  s00: entity work.S0b port map(P(0),                     b00);
  s01: entity work.S1b port map(P(1),      b00,           b01);
  s02: entity work.Sb  port map(x12 , b16, b01,           b02);
  s03: entity work.Sb  port map(x13 , b27, b02,           b03);
  s04: entity work.Sb  port map(x14 , b37, b03,           b04);
  s05: entity work.Sn  port map(x15 ,      b04,           b05);
  U(0) <= b05;
  U(1) <= b16;
  U(2) <= b27;
  U(3) <= b37;
end architecture circuits;  -- of psqrt

library STD;
use STD.textio.all;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_textio.all;
--use IEEE.std_logic_arith.all;
use IEEE.numeric_std.all;

entity sqrt8m is  -- test driver
end sqrt8m;

architecture test of sqrt8m is
  signal P : std_logic_vector(7 downto 0);
  signal U : std_logic_vector(3 downto 0);

  procedure print(P : std_logic_vector(7 downto 0);
                  U : std_logic_vector(3 downto 0)) is
    variable my_line : line;
    alias swrite is write [line, string, side, width] ;
  begin
    swrite(my_line, "sqrt( ");
    write(my_line, P);
    swrite(my_line, " )= ");
    write(my_line, U);
    writeline(output, my_line);
  end print;
  
begin  -- test of sqrt8m
  s1: entity work.psqrt  port map(P, U);    -- parallel code
  driver: process                      -- serial code
          begin  -- process driver
            for I in 0 to 255 loop
              P <= std_logic_vector(to_unsigned(I,8));
              wait for 2 ns;
              print(P, U);
            end loop;
          end process driver;
end architecture test;   -- of sqrt8m


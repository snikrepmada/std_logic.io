-- signal_trace.vhdl     demonstrate how to trace any signal, xxx

-- The technique is to have a process that monitors the signal(s)
-- For each signal, say xxx, create a process in the design unit with the signal
--
-- prtxxx: process (xxx)
--           variable my_line : LINE;
--         begin
--           write(my_line, string'("xxx="));
--           write(my_line, xxx);
--           write(my_line, string'(",  at="));
--           write(my_line, now);
--           writeline(output, my_line);
--         end process prtxxx;
--
-- Obviously edit the above and replace  xxx  with your signal name.
-- Now, every time your signal changes a line out output shows it's value
-- and the time when it changed. Of particular interest is if 'U' or 'X'
-- appears, meaning Uninitialized or X for "don't know" ambiguous.
-- Do not use hwrite, this masks the 'U' and 'X'
-- a specific example is shown below on  sum  and  cout

-- just an example circuit to generate some signals, part of ctest1.vhdl
library IEEE;
use IEEE.std_logic_1164.all;

entity fadd is               -- full adder stage, interface
  port(a    : in  std_logic;
       b    : in  std_logic;
       cin  : in  std_logic;
       s    : out std_logic;
       cout : out std_logic);
end entity fadd;

architecture circuits of fadd is  -- full adder stage, body
begin  -- circuits of fadd
  s <= a xor b xor cin after 1 ns;
  cout <= (a and b) or (a and cin) or (b and cin) after 1 ns;
end architecture circuits; -- of fadd


library IEEE;
use IEEE.std_logic_1164.all;
entity add32 is             -- simple 32 bit ripple carry adder
  port(a    : in  std_logic_vector(31 downto 0);
       b    : in  std_logic_vector(31 downto 0);
       cin  : in  std_logic; 
       sum  : out std_logic_vector(31 downto 0);
       cout : out std_logic);
end entity add32;

architecture circuits of add32 is
  signal c : std_logic_vector(0 to 30); -- internal carry signals
begin  -- circuits of add32
  a0: entity WORK.fadd port map(a(0), b(0), cin, sum(0), c(0));
  stage: for I in 1 to 30 generate
             as: entity WORK.fadd port map(a(I), b(I), c(I-1) , sum(I), c(I));
         end generate stage;
  a31: entity WORK.fadd port map(a(31), b(31), c(30) , sum(31), cout);
end architecture circuits;  -- of add32



use STD.textio.all;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_textio.all;

entity signal_trace is
end signal_trace;

architecture circuits of signal_trace is
  signal a:    std_logic_vector(31 downto 0) := x"00000000";
  signal b:    std_logic_vector(31 downto 0) := x"FFFFFFFF";
  signal cin:  std_logic := '1';
  signal cout: std_logic;            
  signal sum:  std_logic_vector(31 downto 0);
begin  -- circuits of signal_trace
  adder: entity WORK.add32 port map(a, b, cin, sum, cout); -- parallel circuit

  prtsum: process (sum)
            variable my_line : LINE;
          begin
            write(my_line, string'("sum="));
            write(my_line, sum);
            write(my_line, string'(",  at="));
            write(my_line, now);
            writeline(output, my_line);
          end process prtsum;

end architecture circuits; -- of signal_trace

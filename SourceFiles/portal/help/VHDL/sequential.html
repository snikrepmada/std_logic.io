<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<TITLE>VHDL Sequential Statements</TITLE>
</HEAD>
<BODY>
</HEAD>
<BODY>
<P>
|<a href="summary.html">Summary</a>
|<a href="design.html">Design Units</a>
|<a href="sequential.html">Sequential Statements</a>
|<a href="concurrent.html">Concurrent Statements</a>
|<a href="types.html">Predefined Types</a>
|<a href="declare.html">Declarations</a>
|
</P>
<P>
|<a href="misc.html">Resolution and Signatures</a>
|<a href="reserved.html">Reserved Words</a>
|<a href="operator.html">Operators</a>
|<a href="attribute.html">Predefined Attributes</a>
|<a href="stdpkg.html">Standard Packages</a>
|
</P>


<a name="Top"></a>

<H2> VHDL Sequential Statements </H2>

<H4><PRE>These statements are for use in Processes, Procedures and Functions.
The signal assignment statement has unique properties when used sequentially.</PRE></H4>

<H3><a name="Top"> Sequential Statements </a></H3>
<dir>
  <LI><a href="sequential.html#wait"> wait statement </a>
  <LI><a href="sequential.html#asse"> assertion statement </a>
  <LI><a href="sequential.html#repo"> report statement </a>
  <LI><a href="sequential.html#sign"> signal assignment statement </a>
  <LI><a href="sequential.html#vari"> variable assignment statement </a>
  <LI><a href="sequential.html#proc"> procedure call statement </a>
  <LI><a href="sequential.html#if"> if statement </a>
  <LI><a href="sequential.html#case"> case statement </a>
  <LI><a href="sequential.html#loop"> loop statement </a>
  <LI><a href="sequential.html#next"> next statement </a>
  <LI><a href="sequential.html#exit"> exit statement </a>
  <LI><a href="sequential.html#retu"> return statement </a>
  <LI><a href="sequential.html#null"> null statement </a>
</dir>


<H3><a name="wait"> wait statement </a></H3>
<PRE>
Cause execution of sequential statements to wait.

 [ label: ] <B>wait</B> [ sensitivity clause ] [ condition clause ] ;

 <B>wait</B> <B>for</B> 10 ns;              -- timeout clause, specific time delay.
 <B>wait</B> <B>until</B> clk='1';          -- condition clause, Boolean condition
 <B>wait</B> <B>until</B> A&gt;B <B>and</B> S1 <B>or</B> S2; -- condition clause, Boolean condition
 <B>wait</B> <B>on</B> sig1, sig2;          -- sensitivity clause, any event on any
                              -- signal terminates wait

</PRE>

<H3><a name="asse"> assertion statement </a></H3>
<PRE>
Used for internal consistency check or error message generation.

 [ label: ] <B>assert</B> boolean_condition [ <B>report</B> string ] [ <B>severity</B> name ] ;

 <B>assert</B> a=(b <B>or</B> c);
 <B>assert</B> j&lt;i <B>report</B> "internal error, tell someone";
 <B>assert</B> clk='1' <B>report</B> "clock not up" <B>severity</B> WARNING;

 predefined severity names are: NOTE, WARNING, ERROR, FAILURE
 default severity for assert is ERROR

</PRE>

<H3><a name="repo"> report statement </a></H3>
<PRE>
Used to output messages.

 [ label: ] <B>report</B> string [ <B>severity</B> name ] ;

 <B>report</B>  "finished pass1";  -- default severity name is NOTE
 <B>report</B>  "Inconsistent data." <B>severity</B> FAILURE;

</PRE>

<H3><a name="sign"> signal assignment statement </a></H3>
<PRE>
The signal assignment statement is typically considered a concurrent
statement rather than a sequential statement. It can be used as
a sequential statement but has the side effect of obeying the
general rules for when the target actually gets updated.

In particular, a signal can not be declared within a process or
subprogram but must be declared is some other appropriate scope.
Thus the target is updated in the scope where the target is declared
when the sequential code reaches its end or encounters a 'wait'
or other event that triggers the update.

 [ label: ] target &lt;= [ delay_mechanism ] waveform ;

  delay_mechanism
    <B>transport</B>
    <B>reject</B> time_expression
    <B>inertial</B>

  waveform
    waveform_element [, waveform_element]
    <B>unaffected</B>
 
  waveform_element
    value_expression [ <B>after</B> time_expression ]
    <B>null</B> [ <B>after</B> time_expression ]


  sig1 &lt;= sig2;
  Sig &lt;= Sa <B>and</B> Sb <B>or</B> Sc <B>nand</B> Sd <B>nor </B>Se <B>xor</B> Sf <B>xnor</B> Sg;
  sig1 &lt;= sig2 after 10 ns;
  clk &lt;= '1' , '0' <B>after</B> TimePeriod/2 ; 
  sig3 &lt;= <B>transport</B> sig4 after 3 ns;
  sig4 &lt;= <B>reject</B> 2 ns sig5 after 3 ns; -- increasing time order
  sig6 &lt;= <B>inertial</B> '1' after 2 ns, '0' after 3 ns , '1' after 7 ns;

  Note: omitting  [ <B>after</B> time_expression ] is equivalent
        to <B>after</B> 0 fs;

 More information in <a href="concurrent.html#sign">Concurrent Statements signal assignment statement</a>.

</PRE>

<H3><a name="vari"> variable assignment statement </a></H3>
<PRE>
Assign the value of an expression to a target variable.

 [ label: ] target := expression ;

 A := -B + C * D / E <B>mod</B> F <B>rem</B> G <B>abs</B> H;
 Sig := Sa <B>and</B> Sb <B>or</B> Sc <B>nand</B> Sd <B>nor </B>Se <B>xor</B> Sf <B>xnor</B> Sg;

</PRE>

<H3><a name="proc"> procedure call statement </a></H3>
<PRE>
Call a procedure.

 [ label: ] procedure-name [ ( actual parameters ) ] ;

 do_it;  -- no actual parameters

 compute(stuff, A=&gt;a, B=&gt;c+d); -- positional association first,
                                     -- then named association of
                               -- formal parameters to actual parameters

</PRE>

<H3><a name="if"> if statement </a></H3>
<PRE>
Conditional structure.

 [ label: ] <B>if</B>  condition1  <B>then</B>
                 sequence-of-statements
            <B>elsif</B>  condition2  <B>then</B>      \_ optional
                 sequence-of-statements  /
            <B>elsif</B>  condition3  <B>then</B>      \_ optional
                 sequence-of-statements  /
            ...

            <B>else</B>                         \_ optional
                 sequence-of-statements  /
            <B>end</B> <B>if</B> [ label ] ;

 <B>if</B> a=b <B>then</B>
     c:=a;
 <B>elsif</B> b&lt;c <B>then</B>
     d:=b;
     b:=c;
 <B>else</B>
     do_it;
 <B>end</B> <B>if</B>;

</PRE>

<H3><a name="case"> case statement </a></H3>
<PRE>
Execute one specific case of an expression equal to a choice.
The choices must be constants of the same discrete type as the expression.

 [ label: ] <B>case</B>  expression  <B>is</B>
              <B>when</B> choice1 =&gt;
                 sequence-of-statements
              <B>when</B> choice2 =&gt;            \_ optional
                 sequence-of-statements  /
              ...

              <B>when</B> <B>others</B> =&gt;             \_ optional if all choices covered
                 sequence-of-statements  /
            <B>end</B> <B>case</B> [ label ] ;

  <B>case</B>  my_val  <B>is</B>
    <B>when</B> 1 =&gt;
      a:=b;
    <B>when</B> 3 =&gt;
      c:=d;
      do_it;
    <B>when</B> <B>others</B> =&gt;
      <B>null</B>;
  <B>end</B> <B>case</B>;

</PRE>

<H3><a name="loop"> loop statement </a></H3>
<PRE>
Three kinds of iteration statements.

 [ label: ] <B>loop</B>
                 sequence-of-statements -- use exit statement to get out
            <B>end</B> <B>loop</B> [ label ] ;

 [ label: ] <B>for</B> variable <B>in</B> range <B>loop</B>
                 sequence-of-statements
            <B>end</B> <B>loop</B> [ label ] ;

 [ label: ] <B>while</B>  condition  <B>loop</B>
                 sequence-of-statements
            <B>end</B> <B>loop</B> [ label ] ;

  <B>loop</B>
    input_something;
    <B>exit</B> <B>when</B> end_file;
  <B>end</B> <B>loop</B>;

  <B>for</B> I <B>in</B> 1 <B>to</B> 10 <B>loop</B>
    AA(I) := 0;
  <B>end</B> <B>loop</B>;

  <B>while</B> <B>not</B> end_file <B>loop</B>
    input_something;
  <B>end</B> <B>loop</B>;


all kinds of the loops may contain the 'next' and 'exit' statements.

</PRE>

<H3><a name="next"> next statement </a></H3>
<PRE>
A statement that may be used in a loop to cause the next iteration.

 [ label: ] <B>next</B> [ label2 ] [ <B>when</B> condition ] ;

 <B>next</B>;
 <B>next</B> outer_loop;
 <B>next</B> <B>when</B> A&gt;B;
 <B>next</B> this_loop <B>when</B> C=D <B>or</B> done; -- done is a Boolean variable

</PRE>

<H3><a name="exit"> exit statement </a></H3>
<PRE>
A statement that may be used in a loop to immediately exit the loop.

 [ label: ] <B>exit</B> [ label2 ] [ <B>when</B> condition ] ;

 <B>exit</B>;
 <B>exit</B> outer_loop;
 <B>exit</B> <B>when</B> A&gt;B;
 <B>exit</B> this_loop <B>when</B> C=D <B>or</B> done; -- done is a Boolean variable

</PRE>

<H3><a name="retu"> return statement </a></H3>
<PRE>
Required statement in a function, optional in a procedure.

 [ label: ] <B>return</B> [ expression ] ;

 <B>return</B>; -- from somewhere in a procedure
 <B>return</B> a+b; -- returned value in a function

</PRE>

<H3><a name="null"> null statement </a></H3>
<PRE>
Used when a statement is needed but there is nothing to do.

 [ label: ] <B>null</B> ;

 <B>null</B>;

</PRE>

<H3><a name="Other"> Other Links </a></H3>
<UL>
  <LI> <a href="index.shtml">
       VHDL help page
       </a>
  <LI> <a href="samples/samples.shtml">
       Lots of sample VHDL code, from very simple, through I/O, to complex
       </a>
  <LI> <a href="http://tech-www.informatik.uni-hamburg.de/vhdl">
       Hamburg VHDL Archive (the best set of links I have seen!)
       </a>
  <LI> <a href="http://rassp.scra.org/vhdl/tools/tools.html">
       RASSP Project VHDL Tools
       </a>
  <LI> <a href="http://www.vhdl.org">
       VHDL Organization Home Page
       </a>
  <LI> <a href="http://www.freehdl.seul.org">
       gnu GPL VHDL for Linux, under development
       </a>
  <LI> <a href="http://www.ftlsys.com">
       More information on Exploration/VHDL from FTL Systems.
       </a>
</UL>

<H4><a href="sequential.html#Top"> Go to top </a></H4>
<H4><a href="index.shtml"> Go to VHDL index </a></H4>
</BODY>
</HTML>



<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<TITLE>VHDL Compact Summary</TITLE>
</HEAD>
<BODY>
<H3> Version 1.5, please report any issues to squire@umbc.edu </H3>

<H2> Compact Summary of VHDL </H2>

<PRE>
This is not intended as a tutorial. This is a quick reference
guide to find the statement or statement syntax you need
to write VHDL code.

VHDL is case insensitive, upper case letters are equivalent to
lower case letters. Reserved words are in lower case by
convention and shown in bold in this document.

Identifiers are simple names starting with a letter and may
have letters and digits. The underscore character is allowed but
not as the first or last character of an identifier.

A comment starts with minus minus, "--", and continues to
the end of the line.

Indentation is used for human readability. The language is free
form with the characters space, tab and new-line being "white space."

</PRE>


<H3><a name="Top"> Contents </a></H3>
<dir>
  <LI><a href="design.html"> Design units </a>
  <LI><a href="sequential.html"> Sequential Statements </a>
  <LI><a href="concurrent.html"> Concurrent Statements </a>
  <LI><a href="types.html"> Predefined Types </a>
  <LI><a href="declare.html"> Declaration Statements </a>
  <LI><a href="misc.html"> Resolution and Signatures </a>
  <LI><a href="reserved.html"> Reserved Words </a>
  <LI><a href="operator.html"> Operators </a>
  <LI><a href="attribute.html"> Predefined Attributes </a>
  <LI><a href="stdpkg.html"> VHDL standard packages and types </a>
  <LI><a href="summary_one.html#Other"> Other Links </a>
</dir>


<H3><a name="nota"> Notation used in this Compact Summary</a></H3>
<PRE>
  Each item has:
          a very brief explanation of possible use.
          a representative, possibly not complete, syntax schema
          one or more samples of actual VHDL code.

  In the syntax statement  [ stuff ]  means zero or one copy of "stuff".
  In some cases "optional" is used to not clutter up the syntax with [[][]].

  In the examples, assume the appropriate declarations for identifiers,
  appropriate enclosing design unit and appropriate context clauses.

</PRE>

<H2> VHDL Design Units and Subprograms </H2>

<PRE>
A design unit may be the entire file or there may be more than
one design unit in a file. No less than a design unit may be
in a file.

Any design unit may contain a context clause as its initial part.
The context clause of a primary unit applies to all of the
primary units corresponding secondary units.  Architectures and
package bodies are the secondary units. Subprograms are
not library units and must be inside entities, architectures
or packages.

The analysis, compilation, of a design unit results in a library unit
is some design library.  Predefined libraries typically include but are
not limited to: STD, IEEE and WORK.  WORK is the default user library.
</PRE>

<H3>Design Units and Subprograms</H3>
<dir>
  <LI><a href="summary_one.html#entity"> Entity </a>
  <LI><a href="summary_one.html#arch"> Architecture </a>
  <LI><a href="summary_one.html#config"> Configuration </a>
  <LI><a href="summary_one.html#spec"> Package Declaration </a>
  <LI><a href="summary_one.html#body"> Package Body </a>
  <LI><a href="summary_one.html#subpr"> Subprograms </a>
  <LI><a href="summary_one.html#procd"> Procedure Declaration </a>
  <LI><a href="summary_one.html#procb"> Procedure Body </a>
  <LI><a href="summary_one.html#funcd"> Function Declaration </a>
  <LI><a href="summary_one.html#funcb"> Function Body </a>
  <LI><a href="summary_one.html#contx"> Context Clause </a>
  <LI><a href="summary_one.html#order"> Order of Analysis, Compilation </a>
</dir>


<H3><a name="entity"> Entity </a></H3>
<PRE>
The top of every design hierarchy must be an entity.
Entities may range from primitive circuits to complex assemblies.

The entity code typically defines just the interface of the entity.

  <B>entity</B>  identifier <B>is</B>
     <B>generic</B> ( generic_variable_declarations ) ; -- optional
     <B>port</B> ( input_and_output_variable_declarations ) ;
     [ declarations , see allowed list below ]   -- optional
  <B>begin</B>                                         \__ optional
     [ statements , see allowed list below ]    /    
  <B>end</B> <B>entity</B> identifier ;  

  generic_variable_declarations are of the form:
    variable_name : variable_type := variable_value ; -- := variable_value optional

  input_and_output_variable_declaration are of the form:
     variable_name : port_mode  variable_type ;
  port_mode may be <B>in</B> <B>out</B> <B>inout</B> <B>buffer</B> <B>linkage</B>


  <B>entity</B> adder <B>is</B>
     <B>generic</B> ( N : natural := 32 ) ;
     <B>port</B> ( A    : <B>in</B>  bit_vector(N-1 <B>downto</B> 0);
            B    : <B>in</B>  bit_vector(N-1 <B>downto</B> 0);
            cin  : <B>in</B>  bit;
            Sum  : <B>out</B> bit_vector(N-1 <B>downto</B> 0);
            Cout : <B>out</B> bit );
  <B>end</B> <B>entity</B> adder ;


  <B>entity</B> test_bench <B>is</B>   -- typical top level, simulatable, entity
  <B>end</B> <B>entity</B> test_bench;


  <B>entity</B> Latch <B>is</B>
     <B>port</B> ( Din:  <B>in</B>  Word;
            Dout: <B>out</B> Word;
            Load: <B>in</B>  Bit;
            Clk:  <B>in</B>  Bit);
     <B>constant</B> Setup: Time := 12 ns;
     <B>constant</B> PulseWidth: Time := 50 ns;
     <B>use</B> WORK.TimingMonitors.<B>all</B>
  <B>begin</B>
     <b>assert</B> Clk='1' <B>or</B> Clk'Delayed'Stable(PulseWidth);
     CheckTiming(Setup, Din, Load, Clk); -- passive concurrent procedure
  <B>end entity</B> Latch;

The allowed declarations are:
  <a href="summary_one.html#subpr">subprogram declaration</a>
  <a href="summary_one.html#subpr">subprogram body</a>
  <a href="declare.html#Top">type declaration</a>
  <a href="declare.html#sutype">subtype declaration</a>
  <a href="declare.html#cobj">constant, object declaration</a>
  <a href="declare.html#sobj">signal, object declaration</a>
  <a href="declare.html#vobj">variable, object declaration - shared</a>
  <a href="declare.html#fobj">file, object declaration</a>
  <a href="declare.html#alias">alias declaration</a>
  <a href="declare.html#attrd">attribute declaration</a>
  <a href="declare.html#attrs">attribute specification</a>
  <a href="declare.html#disco">disconnection specification</a>
  <a href="summary_one.html#usecl">use clause</a>
  <a href="declare.html#groupt">group template declaration</a>
  <a href="declare.html#group">group declaration</a>

The allowed statements are:
  <a href="concurrent.html#asse">concurrent assertion statements</a>
  <a href="concurrent.html#cpro">passive concurrent procedure call</a>
  <a href="concurrent.html#proc">passive process statement</a>

</PRE>

<H3><a name="arch"> Architecture </a></H3>
<PRE>
Used to implement a design entity. There may be more than one
architecture for a design entity. Typical architectures fall
into classes such as functional simulation or detailed logic
implementation and may be structural, functional(dataflow)
or behavioral. 

  <B>architecture</B> identifier <B>of</B> entity_name <B>is</B>
     [ declarations , see allowed list below ]
  <B>begin</B> -- optional
     [ statements , see allowed list below ]
  <B>end</B> <B>architecture</B> identifier ;  


  <B>architecture</B> circuits <B>of</B> add4c <B>is</B>
    <B>signal</B> c : std_logic_vector(3 <B>downto</B> 0);
    <B>component</B> fadd    -- duplicates entity port
      <B>port</B>(a    : <B>in</B>  std_logic;
           b    : <B>in</B>  std_logic;
           cin  : <B>in</B>  std_logic;
           s    : <B>out</B> std_logic;
           cout : <B>out</B> std_logic);
    <B>end component</B> fadd;
  <B>begin</B>  -- circuits of add4c
    a0: fadd <B>port map</B>(a(0), b(0), cin , sum(0), c(0));
    a1: fadd <B>port map</B>(a(1), b(1), c(0), sum(1), c(1));
    a2: fadd <B>port map</B>(a(2), b(2), c(1), sum(2), c(2));
    a3: fadd <B>port map</B>(a(3), b(3), c(2), sum(3), c(3));
    cout <= (a(3) <B>and</B> b(3)) <B>or</B> ((a(3) <B>or</B> b(3)) <B>and</B>
           ((a(2) <B>and</B> b(2)) <B>or</B> ((a(2) <B>or</B> b(2)) <B>and</B>
           ((a(1) <B>and</B> b(1)) <B>or</B> ((a(1) <B>or</B> b(1)) <B>and</B>
           ((a(0) <B>and</B> b(0)) <B>or</B> ((a(0) <B>or</B> b(0)) <B>and</B> cin)))))))
           <b>after</B> 1 ns;
  <B>end architecture</B> circuits;  -- of add4c


The allowed declarations are:
  <a href="summary_one.html#subpr">subprogram declaration</a>
  <a href="summary_one.html#subpr">subprogram body</a>
  <a href="declare.html#Top">type declaration</a>
  <a href="declare.html#sutype">subtype declaration</a>
  <a href="declare.html#cobj">constant, object declaration</a>
  <a href="declare.html#sobj">signal, object declaration</a>
  <a href="declare.html#vobj">variable, object declaration - shared</a>
  <a href="declare.html#fobj">file, object declaration</a>
  <a href="declare.html#alias">alias declaration</a>
  <a href="declare.html#comp">component declaration</a>
  <a href="declare.html#attrd">attribute declaration</a>
  <a href="declare.html#attrs">attribute specification</a>
  <a href="declare.html#disco">disconnection specification</a>
  <a href="summary_one.html#usecl">use clause</a>
  <a href="declare.html#groupt">group template declaration</a>
  <a href="declare.html#group">group declaration</a>

The allowed statements are:
  <a href="concurrent.html#Top">concurrent statements</a>

</PRE>

<H3><a name="config"> Configuration </a></H3>
<PRE>
Used to bind component instances to design entities and
collect architectures to make, typically, a simulatable
test bench. One configuration could create a functional
simulation while another configuration could create
the complete detailed logic design. With an appropriate
test bench the results of the two configurations
can be compared.

Note that significant nesting depth can occur on hierarchal
designs. There is a capability to bind various architectures
with instances of components in the hierarchy. To avoid nesting
depth use a configuration for each architecture level and a
configuration of configurations. Most VHDL compilation/simulation
systems allow the top level configuration name to be elaborated
and simulated.


  <B>configuration</B> identifier <B>of</B> entity_name <B>is</B>
     [ declarations , see allowed list below ]
     [ block configuration , see allowed list below ]
  <B>end</B> <B>architecture</B> identifier ;  


  -- entities and architecture circuits for fadd, add4c and add32 not shown
  <B>entity</B> add32_test <B>is</B> -- test bench
  <B>end</B> add32_test;

  <B>architecture</B> circuits <B>of</B> add32_test <B>is</B>
     -- details implementing test bench deleted
  <B>end architecture</B> circuits; -- of add32_test


  <B>configuration</B> add32_test_config <B>of</B> add32_test <B>is</B>
    <B>for</B> circuits -- of add32_test
      <B>for all</B>: add32
        <B>use entity</B> WORK.add32(circuits);
        <B>for</B> circuits -- of add32
          <B>for all</B>: add4c
            <B>use entity</B> WORK.add4c(circuits);
            <B>for</B> circuits -- of add4c
              <B>for all</B>: fadd
                <B>use entity</B> WORK.fadd(circuits);
              <B>end for</B>;
            <B>end for</B>;
          <B>end for</B>;
        <B>end for</B>;
      <B>end for</B>;
    <B>end for</B>;
  <B>end configuration</B> add32_test_config;

  Note the architecture name in parenthesis following the entity name.

Or an equivalent configuration of configurations:

  <B>configuration</B> add32_test_config <B>of</B> add32_test <B>is</B>
    <B>for</B> circuits -- of add32_test
      <B>for all</B>: add32
        <B>use configuration</B> WORK.add32_config;
      <B>end for</B>;
    <B>end for</B>;
  <B>end configuration</B> add32_test_config;

  
The allowed declarations are:
  <a href="declare.html#attrs">attribute specification</a>
  <a href="summary_one.html#usecl">use clause</a>
  <a href="declare.html#group">group declaration</a>

The allowed block configurations are:
  <B>for</B> component_instance_name : component_name
     -- use clause
  <B>end for</B>;

  <B>for all</B> : component_name
     -- use clause
  <B>end for</B>;

use clauses are of the form:
   <B>use entity</B> library_name.entity_name[(architecture_name)]
   <B>use configuration</B> library_name.configuration_name

</PRE>

<H3><a name="spec"> Package Declaration </a></H3>
<PRE>
Used to declare types, shared variables, subprograms, etc.

  <B>package</B> identifier <B>is</B>
      [ declarations, see allowed list below ]
  <B>end package</B> identifier ;

  The example is included in the next section, Package Body.

The allowed declarations are:
  <a href="summary_one.html#subpr">subprogram declaration</a>
  <a href="declare.html#Top">type declaration</a>
  <a href="declare.html#sutype">subtype declaration</a>
  <a href="declare.html#cobj">constant, object declaration</a>
  <a href="declare.html#sobj">signal, object declaration</a>
  <a href="declare.html#vobj">variable, object declaration - shared</a>
  <a href="declare.html#fobj">file, object declaration</a>
  <a href="declare.html#alias">alias declaration</a>
  <a href="declare.html#comp">component declaration</a>
  <a href="declare.html#attrd">attribute declaration</a>
  <a href="declare.html#attrs">attribute specification</a>
  <a href="summary_one.html#usecl">use clause</a>
  <a href="declare.html#groupt">group template declaration</a>
  <a href="declare.html#group">group declaration</a>

Declarations not allowed include:
  subprogram body
  
A package body is unnecessary if no subprograms or
deferred constants are declared in the package declaration.

</PRE>

<H3><a name="body"> Package Body </a></H3>
<PRE>
Used to implement the subprograms declared in the package declaration.

  <B>package body</B> identifier <B>is</B>
      [ declarations, see allowed list below ]
  <B>end package body</B> identifier ;

  <B>package</B> my_pkg <B>is</B> -- sample package declaration
    <B>type</B> small <B>is</B> <B>range</B> 0 <B>to</B> 4096;
    <B>procedure</B> s_inc(A : <B>inout</B> small);
    <B>function</B> s_dec(B : small) <B>return</B> small;
  <B>end</B> <B>package</B> my_pkg;

  <B>package</B> <B>body</B> my_pkg <B>is</B> -- corresponding package body
    <B>procedure</B> s_inc(A : <B>inout</B> small) <B>is</B>
    <B>begin</B>
    A := A+1;
    <B>end</B> <B>procedure</B> s_inc;
    <B>function</B> s_dec(B : small) <B>return</B> small is
    <B>begin</B>
      <B>return</B> B-1;
    <B>end function</B> s_dec;
  <B>end package body</B> my_pkg;


The allowed declarations are:
  <a href="summary_one.html#subpr">subprogram declaration</a>
  <a href="summary_one.html#subpr">subprogram body</a>
  <a href="declare.html#Top">type declaration</a>
  <a href="declare.html#sutype">subtype declaration</a>
  <a href="declare.html#cobj">constant, object declaration</a>
  <a href="declare.html#vobj">variable, object declaration - shared</a>
  <a href="declare.html#fobj">file, object declaration</a>
  <a href="declare.html#alias">alias declaration</a>
  <a href="summary_one.html#usecl">use clause</a>
  <a href="declare.html#groupt">group template declaration</a>
  <a href="declare.html#group">group declaration</a>
 
Declarations not allowed include:
  signal, object declaration
  
</PRE>

<H3><a name="subpr"> Subprograms </a></H3>
<PRE>
There are two kinds of subprograms: procedures and functions.

Both procedures and functions written in VHDL must have
a body and may have declarations. 

Procedures perform sequential computations and return values
in global objects or by storing values into formal parameters.

Functions perform sequential computations and return a value
as the value of the function.  Functions do not change their
formal parameters.

Subprograms may exist as just a procedure body or a function body.
Subprograms may also have a procedure declarations or a
function declaration.

When subprograms are provided in a package, the subprogram declaration
is placed in the package declaration and the subprogram body is
placed in the package body.

</PRE>

<H3><a name="procd"> Procedure Declaration </a></H3>
<PRE>
Used to declare the calling interface to a procedure.

  <B>procedure</B> identifier [ ( formal parameter list ) ] ;

  <B>procedure</B> print_header ;
  <B>procedure</B> build ( A : <B>in</B> <B>constant</B> integer;
                    B : <B>inout</B> <B>signal</B> bit_vector;
                    C : <B>out</B> <B>variable</B> real;
                    D : <B>file</B> ) ;

Formal parameters are separated by semicolons in the formal parameter
list.  Each formal parameter is essentially a declaration of an
object that is local to the procedure.  The type definitions used
in formal parameters must be visible at the place where the procedure
is being declared.  No semicolon follows the last formal parameter
inside the parenthesis.

Formal parameters may be constants, variables, signals or files.
The default is variable.

Formal parameters may have modes <B>in</B>, <B>inout</B> and <B>out</B>
Files do not have a mode.
The default is <B>in</B> .

If no type is given and a mode of <B>in</B> is used, constant is the default.

The equivalent default declaration of "build" is

  <B>procedure</B> build ( A : <B>in</B> integer;
                    B : <B>inout</B> <B>signal</B> bit_vector;
                    C : <B>out</B> real;
                    D : <B>file</B> ) ;

</PRE>

<H3><a name="procb"> Procedure Body </a></H3>
<PRE>
Used to define the implementation of the procedure.

  <B>procedure</B> identifier [ ( formal parameter list ) ] <B>is</B>
      [ declarations, see allowed list below ]
  <B>begin</B>
      sequential statement(s)
  <B>end</B> <B>procedure</B> identifier ;

  <B>procedure</B> print_header <B>is</B>
      <B>use</B> STD.textio.all;
      <B>variable</B> my_line : line; 
  <B>begin</B>
      write ( my_line, string'("A    B    C"));
      writeline ( output, my_line );
  <B>end</B> <B>procedure</B> print_header ;

The procedure body formal parameter list is defined above in
Procedure Declaration.  When a procedure declaration is used then
the corresponding procedure body should have exactly the same
formal parameter list.

The allowed declarations are:
  <a href="summary_one.html#subpr">subprogram declaration</a>
  <a href="summary_one.html#subpr">subprogram body</a>
  <a href="declare.html#Top">type declaration</a>
  <a href="declare.html#sutype">subtype declaration</a>
  <a href="declare.html#cobj">constant, object declaration</a>
  <a href="declare.html#vobj">variable, object declaration</a>
  <a href="declare.html#fobj">file, object declaration</a>
  <a href="declare.html#alias">alias declaration</a>
  <a href="summary_one.html#usecl">use clause</a>
  <a href="declare.html#groupt">group template declaration</a>
  <a href="declare.html#group">group declaration</a>
 
Declarations not allowed include:
  signal, object declaration
 
</PRE>

<H3><a name="funcd"> Function Declaration </a></H3>
<PRE>
Used to declare the calling and return interface to a function.

  <B>function</B> identifier [ ( formal parameter list ) ] <B>return</B> a_type ;

  <B>function</B> random <B>return</B> float ;
  <B>function</B> is_even ( A : integer) <B>return</B> boolean ;

Formal parameters are separated by semicolons in the formal parameter
list.  Each formal parameter is essentially a declaration of an
object that is local to the function.  The type definitions used
in formal parameters must be visible at the place where the function
is being declared.  No semicolon follows the last formal parameter
inside the parenthesis.

Formal parameters may be constants, signals or files.
The default is constant.

Formal parameters have the mode <B>in</B>.
Files do not have a mode.
Note that  <B>inout</B> and <B>out</B> are not allowed for functions.
The default is <B>in</B> .

The reserved word <B>function</B> may be preceded by nothing,
implying <B>pure</B> , <B>pure</B> or <B>impure</B> .
A <B>pure function</B> must not contain a reference to a file object,
slice, subelement, shared variable or signal with attributes
such as 'delayed, 'stable, 'quiet, 'transaction and must not
be a parent of an impure function.

</PRE>

<H3><a name="funcb"> Function Body </a></H3>
<PRE>
Used to define the implementation of the function.

  <B>function</B> identifier [ ( formal parameter list ) ]
                  <B>return</B> a_type <B>is</B>
      [ declarations, see allowed list below ]
  <B>begin</B>
      sequential statement(s)
      return some_value; -- of type  a_type
  <B>end</B> <B>function</B> identifier ;

  <B>function</B> random <B>return</B> float <B>is</B>
       variable X : float;
  <B>begin</B>
       -- compute X
       <B>return</B> X;
  <B>end</B> <B>function</B> random ;

The function body formal parameter list is defined above in
Function Declaration.  When a function declaration is used then
the corresponding function body should have exactly the same
formal parameter list.

The allowed declarations are:
  <a href="summary_one.html#subpr">subprogram declaration</a>
  <a href="summary_one.html#subpr">subprogram body</a>
  <a href="declare.html#Top">type declaration</a>
  <a href="declare.html#sutype">subtype declaration</a>
  <a href="declare.html#cobj">constant, object declaration</a>
  <a href="declare.html#vobj">variable, object declaration</a>
  <a href="declare.html#fobj">file, object declaration</a>
  <a href="declare.html#alias">alias declaration</a>
  <a href="summary_one.html#usecl">use clause</a>
  <a href="declare.html#groupt">group template declaration</a>
  <a href="declare.html#group">group declaration</a>
 
Declarations not allowed include:
  signal, object declaration

</PRE>

<H3><a name="contx"> Context Clause </a></H3>
<PRE>
Used to name a library and make library units visible
to the design unit that immediately follows.

  <B>library</B> library_name ;
  <B>use</B> library_name.unit_name.<B>all</B> ;

  <B>library</B> STD ;
<a name="usecl">  <B>use</B> STD.textio.<B>all</B>;</a>

  <B>library</B> ieee ;
  <B>use</B> ieee.std_logic_1164.<B>all</B>;
  <B>use</B> ieee.std_logic_textio.<B>all</B>;
  <B>use</B> ieee.std_logic_arith.<B>all</B>;
  <B>use</B> ieee.numeric_std.<B>all</B>;
  <B>use</B> ieee.numeric_bit.<B>all</B>;
  <B>use</B> WORK.my_pkg.s_inc; -- select one item from package

Note that the .<B>all</B> makes everything visible. It is
optional and when not used the prefix such as
   ieee.std_logic_1164.   must be used on every reference
to an item in the library unit.  Specific items in the
library unit may be listed in place of  .<B>all</B> .

The libraries STD and WORK do not need a library specification
on most systems.  <B>library</B> ieee or equivalent <B>library</B> IEEE
is needed on most systems.

</PRE>

<H3><a name="order"> Order of Analysis, Compilation </a></H3>
<PRE>
Every design unit must be analyzed, compiled, before it can
be used by another design unit. The result of the analysis
or compilation results in an analyzed design in a library.
The analyzed design goes into the default library WORK
unless otherwise specified.

An entity must be analyzed, compiled, before its corresponding
architectures or configurations.

A package declaration must be analyzed, compiled, before its
corresponding package body.

A package declaration must be analyzed, compiled, before it can
be referenced in a context clause.  For example:

     Analyze, compile
          <B>package</B> my_package <B>is</B>
            -- declarations
          <B>end package</B> my_package;

     then analyze, compile
          <B>library</B> WORK;  -- this line usually not needed
          <B>use</B> WORK.my_package.<B>all</B>
          <B>entity</B> my_entity <B>is</B>
            -- entity stuff
          <B>end entity</B> my_entity;



</PRE>

<H2> VHDL Sequential Statements </H2>

<H4><PRE>These statements are for use in Processes, Procedures and Functions.
The signal assignment statement has unique properties when used sequentially.</PRE></H4>

<H3><a name="Top"> Sequential Statements </a></H3>
<dir>
  <LI><a href="summary_one.html#wait"> wait statement </a>
  <LI><a href="summary_one.html#asse"> assertion statement </a>
  <LI><a href="summary_one.html#repo"> report statement </a>
  <LI><a href="summary_one.html#sign"> signal assignment statement </a>
  <LI><a href="summary_one.html#vari"> variable assignment statement </a>
  <LI><a href="summary_one.html#proc"> procedure call statement </a>
  <LI><a href="summary_one.html#if"> if statement </a>
  <LI><a href="summary_one.html#case"> case statement </a>
  <LI><a href="summary_one.html#loop"> loop statement </a>
  <LI><a href="summary_one.html#next"> next statement </a>
  <LI><a href="summary_one.html#exit"> exit statement </a>
  <LI><a href="summary_one.html#retu"> return statement </a>
  <LI><a href="summary_one.html#null"> null statement </a>
</dir>


<H3><a name="wait"> wait statement </a></H3>
<PRE>
Cause execution of sequential statements to wait.

 [ label: ] <B>wait</B> [ sensitivity clause ] [ condition clause ] ;

 <B>wait</B> <B>for</B> 10 ns;              -- timeout clause, specific time delay.
 <B>wait</B> <B>until</B> clk='1';          -- condition clause, Boolean condition
 <B>wait</B> <B>until</B> A&gt;B <B>and</B> S1 <B>or</B> S2; -- condition clause, Boolean condition
 <B>wait</B> <B>on</B> sig1, sig2;          -- sensitivity clause, any event on any
                              -- signal terminates wait

</PRE>

<H3><a name="asse"> assertion statement </a></H3>
<PRE>
Used for internal consistency check or error message generation.

 [ label: ] <B>assert</B> boolean_condition [ <B>report</B> string ] [ <B>severity</B> name ] ;

 <B>assert</B> a=(b <B>or</B> c);
 <B>assert</B> j&lt;i <B>report</B> "internal error, tell someone";
 <B>assert</B> clk='1' <B>report</B> "clock not up" <B>severity</B> WARNING;

 predefined severity names are: NOTE, WARNING, ERROR, FAILURE
 default severity for assert is ERROR

</PRE>

<H3><a name="repo"> report statement </a></H3>
<PRE>
Used to output messages.

 [ label: ] <B>report</B> string [ <B>severity</B> name ] ;

 <B>report</B>  "finished pass1";  -- default severity name is NOTE
 <B>report</B>  "Inconsistent data." <B>severity</B> FAILURE;

</PRE>

<H3><a name="sign"> signal assignment statement </a></H3>
<PRE>
The signal assignment statement is typically considered a concurrent
statement rather than a sequential statement. It can be used as
a sequential statement but has the side effect of obeying the
general rules for when the target actually gets updated.

In particular, a signal can not be declared within a process or
subprogram but must be declared is some other appropriate scope.
Thus the target is updated in the scope where the target is declared
when the sequential code reaches its end or encounters a 'wait'
or other event that triggers the update.

 [ label: ] target &lt;= [ delay_mechanism ] waveform ;

  delay_mechanism
    <B>transport</B>
    <B>reject</B> time_expression
    <B>inertial</B>

  waveform
    waveform_element [, waveform_element]
    <B>unaffected</B>
 
  waveform_element
    value_expression [ <B>after</B> time_expression ]
    <B>null</B> [ <B>after</B> time_expression ]


  sig1 &lt;= sig2;
  Sig &lt;= Sa <B>and</B> Sb <B>or</B> Sc <B>nand</B> Sd <B>nor </B>Se <B>xor</B> Sf <B>xnor</B> Sg;
  sig1 &lt;= sig2 after 10 ns;
  clk &lt;= '1' , '0' <B>after</B> TimePeriod/2 ; 
  sig3 &lt;= <B>transport</B> sig4 after 3 ns;
  sig4 &lt;= <B>reject</B> 2 ns sig5 after 3 ns; -- increasing time order
  sig6 &lt;= <B>inertial</B> '1' after 2 ns, '0' after 3 ns , '1' after 7 ns;

  Note: omitting  [ <B>after</B> time_expression ] is equivalent
        to <B>after</B> 0 fs;

 More information in <a href="concurrent.html#sign">Concurrent Statements signal assignment statement</a>.

</PRE>

<H3><a name="vari"> variable assignment statement </a></H3>
<PRE>
Assign the value of an expression to a target variable.

 [ label: ] target := expression ;

 A := -B + C * D / E <B>mod</B> F <B>rem</B> G <B>abs</B> H;
 Sig := Sa <B>and</B> Sb <B>or</B> Sc <B>nand</B> Sd <B>nor </B>Se <B>xor</B> Sf <B>xnor</B> Sg;

</PRE>

<H3><a name="proc"> procedure call statement </a></H3>
<PRE>
Call a procedure.

 [ label: ] procedure-name [ ( actual parameters ) ] ;

 do_it;  -- no actual parameters

 compute(stuff, A=&gt;a, B=&gt;c+d); -- positional association first,
                                     -- then named association of
                               -- formal parameters to actual parameters

</PRE>

<H3><a name="if"> if statement </a></H3>
<PRE>
Conditional structure.

 [ label: ] <B>if</B>  condition1  <B>then</B>
                 sequence-of-statements
            <B>elsif</B>  condition2  <B>then</B>      \_ optional
                 sequence-of-statements  /
            <B>elsif</B>  condition3  <B>then</B>      \_ optional
                 sequence-of-statements  /
            ...

            <B>else</B>                         \_ optional
                 sequence-of-statements  /
            <B>end</B> <B>if</B> [ label ] ;

 <B>if</B> a=b <B>then</B>
     c:=a;
 <B>elsif</B> b&lt;c <B>then</B>
     d:=b;
     b:=c;
 <B>else</B>
     do_it;
 <B>end</B> <B>if</B>;

</PRE>

<H3><a name="case"> case statement </a></H3>
<PRE>
Execute one specific case of an expression equal to a choice.
The choices must be constants of the same discrete type as the expression.

 [ label: ] <B>case</B>  expression  <B>is</B>
              <B>when</B> choice1 =&gt;
                 sequence-of-statements
              <B>when</B> choice2 =&gt;            \_ optional
                 sequence-of-statements  /
              ...

              <B>when</B> <B>others</B> =&gt;             \_ optional if all choices covered
                 sequence-of-statements  /
            <B>end</B> <B>case</B> [ label ] ;

  <B>case</B>  my_val  <B>is</B>
    <B>when</B> 1 =&gt;
      a:=b;
    <B>when</B> 3 =&gt;
      c:=d;
      do_it;
    <B>when</B> <B>others</B> =&gt;
      <B>null</B>;
  <B>end</B> <B>case</B>;

</PRE>

<H3><a name="loop"> loop statement </a></H3>
<PRE>
Three kinds of iteration statements.

 [ label: ] <B>loop</B>
                 sequence-of-statements -- use exit statement to get out
            <B>end</B> <B>loop</B> [ label ] ;

 [ label: ] <B>for</B> variable <B>in</B> range <B>loop</B>
                 sequence-of-statements
            <B>end</B> <B>loop</B> [ label ] ;

 [ label: ] <B>while</B>  condition  <B>loop</B>
                 sequence-of-statements
            <B>end</B> <B>loop</B> [ label ] ;

  <B>loop</B>
    input_something;
    <B>exit</B> <B>when</B> end_file;
  <B>end</B> <B>loop</B>;

  <B>for</B> I <B>in</B> 1 <B>to</B> 10 <B>loop</B>
    AA(I) := 0;
  <B>end</B> <B>loop</B>;

  <B>while</B> <B>not</B> end_file <B>loop</B>
    input_something;
  <B>end</B> <B>loop</B>;


all kinds of the loops may contain the 'next' and 'exit' statements.

</PRE>

<H3><a name="next"> next statement </a></H3>
<PRE>
A statement that may be used in a loop to cause the next iteration.

 [ label: ] <B>next</B> [ label2 ] [ <B>when</B> condition ] ;

 <B>next</B>;
 <B>next</B> outer_loop;
 <B>next</B> <B>when</B> A&gt;B;
 <B>next</B> this_loop <B>when</B> C=D <B>or</B> done; -- done is a Boolean variable

</PRE>

<H3><a name="exit"> exit statement </a></H3>
<PRE>
A statement that may be used in a loop to immediately exit the loop.

 [ label: ] <B>exit</B> [ label2 ] [ <B>when</B> condition ] ;

 <B>exit</B>;
 <B>exit</B> outer_loop;
 <B>exit</B> <B>when</B> A&gt;B;
 <B>exit</B> this_loop <B>when</B> C=D <B>or</B> done; -- done is a Boolean variable

</PRE>

<H3><a name="retu"> return statement </a></H3>
<PRE>
Required statement in a function, optional in a procedure.

 [ label: ] <B>return</B> [ expression ] ;

 <B>return</B>; -- from somewhere in a procedure
 <B>return</B> a+b; -- returned value in a function

</PRE>

<H3><a name="null"> null statement </a></H3>
<PRE>
Used when a statement is needed but there is nothing to do.

 [ label: ] <B>null</B> ;

 <B>null</B>;

</PRE>

<H2> VHDL Concurrent Statements </H2>

<H4><PRE>These statements are for use in Architectures.</PRE></H4>

<H3> Concurrent Statements </H3>
<dir>
  <LI><a href="summary_one.html#bloc"> block statement </a>
  <LI><a href="summary_one.html#proc"> process statement </a>
  <LI><a href="summary_one.html#cpro"> concurrent procedure call statement </a>
  <LI><a href="summary_one.html#asse"> concurrent assertion statement </a>
  <LI><a href="summary_one.html#sign"> concurrent signal assignment statement </a>
  <LI><a href="summary_one.html#cond"> conditional signal assignment statement </a>
  <LI><a href="summary_one.html#sele"> selected signal assignment statement </a>
  <LI><a href="summary_one.html#inst"> component instantiation statement </a>
  <LI><a href="summary_one.html#gene"> generate statement </a>
</dir>

<H3><a name="bloc"> block statement </a></H3>
<PRE>
Used to group concurrent statements, possibly hierarchically.

  label : <B>block</B> [ ( guard expression ) ] [ <B>is</B> ]
             [ generic clause [ generic map aspect ; ] ]
             [ port clause [ port map aspect ; ] ]
             [ block declarative items ]
          <B>begin</B>
             concurrent statements
          <B>end</B> <B>block</B> [ label ] ;

  clump : <B>block</B>
          <B>begin</B>
            A &lt;= B <B>or</B> C;
            D &lt;= B <B>and</B> <B>not</B> C;
          <B>end</B> <B>block</B> clump ;

  maybe : <B>block</B> ( B'stable(5 ns) ) <B>is</B>
             <B>port</B> (A, B, C : <B>inout</B> std_logic );
             <B>port</B> <B>map</B> ( A =&gt; S1, B =&gt; S2, C =&gt; outp );
             <B>constant</B> delay: time := 2 ns;
             <B>signal</B> temp: std_logic;
          <B>begin</B>
             temp &lt;= A <B>xor</B> B <B>after</B> delay;
             C &lt;= temp <B>nor</B> B;
          <B>end</B> <B>block</B> maybe; 

</PRE>

<H3><a name="proc"> process statement </a></H3>
<PRE>
Used to do have sequential statements be a part of concurrent processing.

  label : <B>process</B> [ ( sensitivity_list ) ] [ <B>is</B> ]
             [ process_declarative_items ]
          <B>begin</B>
             sequential statements
          <B>end</B> <B>process</B> [ label ] ;

         -- input and output are defined a type 'word' signals
  reg_32: <B>process</B>(clk, clear)
          <B>begin</B>
            <B>if</B> clear='1' <B>then</B>
              output &lt;= (<B>others</B>=>'0');
            <B>elsif</B> clk='1' <B>then</B>
              output &lt;= input <B>after</B> 250 ps;
            <B>end if</B>;
          <B>end process</B> reg_32;

           -- assumes  use IEEE.std_logic_textio.all
  printout:  <B>process</B>(clk) -- used to show state when clock raises
               <B>variable</B> my_line : LINE;   -- not part of working circuit
             <B>begin</B>
               <B>if</B> clk='1' <B>then</B>
                 write(my_line, string'("at clock "));
                 write(my_line, counter);
                 write(my_line, string'("  PC="));
                 write(my_line, IF_PC);
                 writeline(output, my_line);
                 counter &lt;= counter+1;
               <B>end if</B>;
             <B>end process</B> printout;


  process_declarative_items are any of:
  <a href="summary_one.html#subpr">subprogram declaration</a>
  <a href="summary_one.html#subpr">subprogram body</a>
  <a href="declare.html#Top">type declaration</a>
  <a href="declare.html#sutype">subtype declaration</a>
  <a href="declare.html#cobj">constant, object declaration</a>
  <a href="declare.html#vobj">variable, object declaration</a>
  <a href="declare.html#fobj">file, object declaration</a>
  <a href="declare.html#alias">alias declaration</a>
  <a href="declare.html#attrd">attribute declaration</a>
  <a href="declare.html#attrs">attribute specification</a>
  <a href="summary_one.html#usecl">use clause</a>
  <a href="declare.html#groupt">group template declaration</a>
  <a href="declare.html#group">group declaration</a>

  BUT NOT signal_declaration, all signals must be declared outside the process.
    sig1 &lt;= sig2 and sig3; -- considered here as a sequential statement
                          -- sig1 is set outside the process upon exit or wait

A process may be designated as <B>postponed</B> in which case it starts in the 
same simulation cycle as an equivalent non postponed process,
yet starts after all other non postponed processes have suspended
in that simulation cycle.

</PRE>

<H3><a name="cpro"> concurrent procedure call statement </a></H3>
<PRE>
A sequential procedure call statement may be used and its behavior
is that of an equivalent process. 

  [ label : ] [ <B>postponed</B> ] procedure name [ ( actual_parameters ) ] ;

  trigger_some_event ;

  Check_Timing(min_time, max_time, clk, sig_to_test);

Note that a procedure can be defined in a library package and
then used many places.  A process can not be similarly defined
in a package and may have to be physically copied.  A process
has some additional capability not available in a concurrent
procedure.

</PRE>

<H3><a name="asse"> concurrent assertion statement </a></H3>
<PRE>
A sequential assertion statement may be used and its behavior is that
of an equivalent process.

  [ label : ] [ <B>postponed</B> ] assertion_statement ;


</PRE>

<H3><a name="sign"> concurrent signal assignment statement </a></H3>
<PRE>
A <a href="sequential.html#sign">sequential signal assignment statement</a> is also a concurrent signal
assignment statement. Additional control is provided by the use
of <B>postponed</B> and <B>guarded</B>.

  [ label : ] <a href="sequential.html#sign">sequential signal assignment statement</a>

  [ label : ] [ <B>postponed</B> ] conditional_signal_assignment_statement ;

  [ label : ] [ <B>postponed</B> ] selected_signal_assignment_statement ;


The optional <B>guarded</B> causes the statement to be executed when
the <B>guarded</B> signal changes from False to True.
</PRE>


<H3><a name="cond"> conditional signal assignment statement </a></H3>
<PRE>
A conditional assignment statement is also a concurrent signal
assignment statement.

  target &lt;= waveform <B>when</B> choice; -- choice is a boolean expression
  target &lt;= waveform <B>when</B> choice <B>else</B> waveform;

  sig &lt;= a_sig <B>when</B> count&gt;7;
  sig2 &lt;= not a_sig after 1 ns <B>when</B> ctl='1' <B>else</B> b_sig;

  "waveform" for this statement seems to include [ delay_mechanism ]
  See <a href="sequential.html#sign">sequential signal assignment statement</a>

</PRE>


<H3><a name="sele"> selected signal assignment statement </a></H3>
<PRE>
A selected assignment statement is also a concurrent signal
assignment statement.

  <B>with</B> expression <B>select</B> target &lt;=
             waveform <B>when</B> choice [, waveform <B>when</B> choice ] ;

  <B>with</B> count/2 <B>select</B> my_ctrl &lt;=
                 '1' <B>when</B> 1, -- count/2 = 1 for this choice
                 '0' <B>when</B> 2,
                 'X' <B>when</B> <B>others</B>;

</PRE>


<H3><a name="inst"> component instantiation statement </a></H3>
<PRE>
Get a specific architecture-entity instantiated component.

  part_name: <B>entity</B>  library_name.entity_name(architecture_name)
             <B>port map</B> ( actual arguments ) ;

                                              optional (architecture_name)
  part_name: component_name
             <B>port map</B> ( actual arguments ) ;


  Given  <B>entity</B> gate <B>is</B>
            <B>port</B> (in1  : <B>in</B>  std_logic ;
                  in2  : <B>in</B>  std_logic ;
                  out1 : <B>out</B> std_logic) ;
         <B>end entity</B> gate;
         <B>architecture</B> circuit <B>of</B> gate <B>is</B> ...
         <B>architecture</B> behavior <B>of</B> gate <B>is</B> ...

  A101: <B>entity</B> WORK.gate(circuit)
            <B>port map</B> ( in1 => a, in2 => b, out1 => c );

        -- when gate has only one architecture
  A102: <B>entity</B> WORK.gate
            <B>port map</B> ( in1 => a, in2 => b, out1 => c );

        -- when order of actual arguments is used
  A103: <B>entity</B> WORK.gate
            <B>port map</B> ( a, b, c );

  Given an entity
  <B>entity</B> add_32 <B>is</B> -- could have several architectures
      <B>port</B> (a    : <B>in</B>  std_logic_vector (31 <B>downto</B> 0);
            b    : <B>in</B>  std_logic_vector (31 <B>downto</B> 0);
            cin  : <B>in</B>  std_logic;
            sum  : <B>out</B> std_logic_vector (31 <B>downto</B> 0);
            cout : <B>out</B> std_logic);
  <B>end entity</B> add_32;

  Create a simple component interface
  <B>component</B> add_32 -- use same port as entity
      <B>port</B> (a    : <B>in</B>  std_logic_vector (31 <B>downto</B> 0);
            b    : <B>in</B>  std_logic_vector (31 <B>downto</B> 0);
            cin  : <B>in</B>  std_logic;
            sum  : <B>out</B> std_logic_vector (31 <B>downto</B> 0);
            cout : <B>out</B> std_logic);
  <B>end component </B>add_32;

  Instantiate the component 'add_32' to part name 'PC_incr'
  PC_incr : add_32 <B>port map</B> (PC, four, zero, PC_next, nc1);


  Create a component interface, changing name and renaming arguments
  <B>component</B> adder  -- can have any name but same types in port
      <B>port</B> (in1  : <B>in</B>  std_logic_vector (31 <B>downto</B> 0);
            in2  : <B>in</B>  std_logic_vector (31 <B>downto</B> 0);
            cin  : <B>in</B>  std_logic;
            sum  : <B>out</B> std_logic_vector (31 <B>downto</B> 0);
            cout : <B>out</B> std_logic);
  <B>end component </B>adder;

  Instantiate the component 'adder' to part name 'PC_incr'
  PC_incr : adder  -- configuration may associate a specific architecture
            <B>port map</B> (in1  => PC,
                      in2  => four,
                      cin  => zero,
                      sum  => PC_next,
                      cout => nc1);

</PRE>

<H3><a name="gene"> generate statement </a></H3>
<PRE>
Make copies of concurrent statements

  label: <B>for</B> variable <B>in</B> range <B>generate</B>    -- label required
            block declarative items  \__ optional   
         <B>begin</B>                       /
            concurrent statements          -- using variable
         <B>end</B> <B>generate</B> label ;

  label: <B>if</B> condition <B>generate</B>            -- label required
            block declarative items  \__ optional   
         <B>begin</B>                       /
            concurrent statements
         <B>end</B> <B>generate</B> label ;

  band : <B>for</B> I <B>in</B> 1 <B>to</B> 10 <B>generate</B>
  b2 :      <B>for</B> J <B>in</B> 1 <B>to</B> 11 <B>generate</B>
  b3 :         <B>if</B> <B>abs</B>(I-J)&lt;2 <B>generate</B>
                   part: foo <B>port</B> <B>map</B> ( a(I), b(2*J-1), c(I, J) );
               <B>end</B> <B>generate</B> b3;
            <B>end</B> <B>generate</B> b2;
         <B>end</B> <B>generate</B> band;

</PRE>


<H2> VHDL Predefined Types from the package standard </H2>

<PRE>
The type and subtype names below are automatically defined.
They are not technically reserved words but save yourself a lot
of grief and do not re-define them.

Note that enumeration literals such as "true" and "false"
are not technically reserver words and can be easily overloaded,
but save future readers of your code the confusion.
It is confusing enough that '0' and '1' are enumeration
literals of both type Character and type Bit.
"01101001" is of type string, bit_vector, std_logic_vector and more.

There is no automatic type conversion in VHDL, yet users and libraries
may provide almost any type conversion. For numeric types
integer(X) yields the rounded value of the real variable X as an integer,
real(I) yields the value of the integer variable I as a real.

</PRE>

<H3><a name="Top"> Predefined type declarations </a></H3>

<PRE>

Notes: Reserver words are in bold type,
Type names are alphabetical and begin with an initial uppercase letter.
Enumeration literals are in plain lower case.

<B>type</B> Bit <B>is</B> ('0', '1');

<B>type</B> Bit_vector <B>is</B> <B>array</B> (Natural <B>range</B> &lt;&gt;) <B>of</B> Bit;

<B>type</B> Boolean <B>is</B> (false, true);

<B>type</B> Character <B>is</B> ( --256 characters-- );

<B>subtype</B> Delay_length <B>is</B> Time <B>range</B> 0 fs <B>to</B> Time'high;

<B>type</B> File_open_kind <B>is</B> (read_mode, write_mode, append_mode);

<B>type</B> File_open_status <B>is</B> (open_ok, status_error, name_error, mode_error);

<B>type</B> Integer <B>is</B> <B>range</B> --usually typical integer-- ;

<B>subtype</B> Natural <B>is</B> Integer <B>range</B> 0 <B>to</B> Integer'high;

<B>subtype</B> Positive <B>is</B> Integer <B>range</B> 1 <B>to</B> Integer'high;

<B>type</B> Real <B>is</B> <B>range</B> --usually double precision floating point-- ;

<B>type</B> Severity_level <B>is</B> (note, warning, error, failure);

<B>type</B> String <B>is</B> <B>array</B> (Positive <B>range</B> &lt;&gt;) <B>of</B> Character;

<B>type</B> Time <B>is</B> <B>range</B> --implementation defined-- ;
  <B>units</B>
     fs;            -- femtosecond
     ps  = 1000 fs; -- picosecond
     ns  = 1000 ps; -- nanosecond
     us  = 1000 ns; -- microsecond
     ms  = 1000 us; -- millisecond
     sec = 1000 ms; -- second
     min = 60  sec; -- minute
     hr  = 60  min; -- hour
  <B>end</B> <B>units</B>;


<B>attribute</B> Foreign : String ;

<B>impure</B> <B>function</B> Now <B>return</B> Delay_length;

The type classification of VHDL is shown below.
  Users can declare their own types and subtypes.
  A <B>type</B> statement is used to declare a new type.
  A <B>subtype</B> statement is used to constrain an existing type.

types-+-scalar----+-discrete-------+-integer-------+-integer
      |           |                |               +-natural
      |           |                |               +-positive
      |           |                |
      |           |                +-enumeration---+-boolean
      |           |                                +-bit
      |           |                                +-character
      |           |                                +-file_open_kind
      |           |                                +-file_open_status
      |           |                                +-severity_level
      |           |
      |           +-floating point-+-----------------real
      |           |
      |           +-physical-------+-----------------delay_length
      |                            +-----------------time
      |
      +-composite-+-array----------+-constrained-
      |           |                |
      |           |                +-unconstrained-+-bit_vector
      |           |                                +-string
      |           |
      |           +-record-
      |
      +-access-
      |
      +-file-

</PRE>











<H2> VHDL Declaration Statements </H2>

<H4><PRE>Various declarations may be used in various design units.
Check the particular design unit for applicability.</PRE></H4>

<H3><a name="Top"> Declaration Statements </a></H3>
<dir>
  <LI><a href="summary_one.html#itype"> incomplete type declaration </a>
  <LI><a href="summary_one.html#stype"> scalar type declaration </a>
  <LI><a href="summary_one.html#ctype"> composite type declaration </a>
  <LI><a href="summary_one.html#atype"> access type declaration </a>
  <LI><a href="summary_one.html#ftype"> file type declaration </a>
  <LI><a href="summary_one.html#sutype"> subtype declaration </a>
  <LI><a href="summary_one.html#cobj"> constant, object declaration </a>
  <LI><a href="summary_one.html#sobj"> signal, object declaration </a>
  <LI><a href="summary_one.html#vobj"> variable, object declaration </a>
  <LI><a href="summary_one.html#fobj"> file, object declaration </a>
  <LI><a href="summary_one.html#alias"> alias declarations </a>
  <LI><a href="summary_one.html#attrd"> attribute declaration </a>
  <LI><a href="summary_one.html#attrs"> attribute specification </a>
  <LI><a href="summary_one.html#comp"> component declaration </a>
  <LI><a href="summary_one.html#groupt"> group template declaration </a>
  <LI><a href="summary_one.html#group"> group declaration </a>
  <LI><a href="summary_one.html#disco"> disconnect specification </a>
</dir>

<H3><a name="itype"> incomplete type declaration </a></H3>
<PRE>
Declare an identifier to be a type.
The full type definition must be provided within this scope.

 <B>type</B> identifier ;

 <B>type</B> node ;

</PRE>

<H3><a name="stype"> scalar type declaration </a></H3>
<PRE>
Declare a type that may be used to create scalar objects.

 <B>type</B> identifier <B>is</B> scalar_type_definition ;

 <B>type</B> my_small <B>is</B> <B>range</B> -5 to 5 ;
 <B>type</B> my_bits  <B>is</B> <B>range</B> 31 downto 0 ;
 <B>type</B> my_float <B>is</B> <B>range</B> 1.0 to 1.0E6 ;

</PRE>

<H3><a name="ctype"> composite type declaration </a></H3>
<PRE>
Declare a type for creating array, record or unit objects.

 <B>type</B> identifier <B>is</B> composite_type_definition ;

 <B>type</B> word <B>is</B> <B>array</B> (0 <B>to</B> 31) <B>of</B> bit;
 <B>type</B> data <B>is</B> <B>array</B> (7 <B>downto</B> 0) <B>of</B> word;
 <B>type</B> mem <B>is</B> <B>array</B> (natural <B>range</B> &lt;&gt;) <B>of</B> word;
 <B>type</B> matrix <B>is</B> <B>array</B> (integer <B>range</B> &lt;&gt;,
                       integer <B>range</B> &lt;&gt;) <B>of</B> real;


 <B>type</B> stuff <B>is</B>
   <B>record</B>
       I : integer;
       X : real;
       day : integer <B>range</B> 1 <B>to</B> 31;
       name : string(1 <B>to</B> 48);
       prob : matrix(1 <B>to</B> 3, 1 <B>to</B> 3);
   <B>end</B> <B>record</B>;

 <B>type</B> node <B>is</B> -- binary tree
   <B>record</B>
       key   : string(1 <B>to</B> 3);
       data  : integer;
       left  : node_ptr;
       right : node_ptr;
       color : color_type;
   <B>end</B> <B>record</B>;


 <B>type</B> distance <B>is</B> <B>range</B> 0 <B>to</B> 1E16
    <B>units</B>
      Ang;                 -- angstrom
      nm   = 10 Ang;       -- nanometer
      um   = 1000 nm;      -- micrometer (micron)
      mm   = 1000 um;      -- millimeter
      cm   = 10 mm;        -- centimeter
      dm   = 100 mm;       -- decameter
      m    = 1000 mm;      -- meter
      km   = 1000 m;       -- kilometer

      mil  = 254000 Ang;   -- mil (1/1000 inch)
      inch = 1000 mil;     -- inch
      ft   = 12 inch;      -- foot
      yd   = 3 ft;         -- yard
      fthn = 6 ft;         -- fathom
      frlg = 660 ft;       -- furlong
      mi   = 5280 ft;      -- mile
      lg   = 3 mi;         -- league
    <B>end</B> <B>units</B>;

</PRE>

<H3><a name="atype"> access type declaration </a></H3>
<PRE>
Declare a type for creating access objects, pointers.
An object of an access type must be of class variable.
An object

 <B>type</B> identifier <B>is</B> <B>access</B> subtype_indication;

 <B>type</B> node_ptr <B>is</B> <B>access</B> node;

 <B>variable</B> root : node_ptr := <B>new</B> node'("xyz", 0, null, null, red);
 <B>variable</B> item : node := root.all;

</PRE>

<H3><a name="ftype"> file type declaration </a></H3>
<PRE>
Declare a type for creating file handles.

 <B>type</B> identifier <B>is</B> <B>file</B> <B>of</B> type_mark ;

 <B>type</B> my_text <B>is</B> <B>file</B> <B>of</B> string ;

 <B>type</B> word_file <B>is</B> <B>file</B> <B>of</B> word ;

 <B>file</B> output : my_text;
 file_open(output, "my.txt", write_mode);
 write(output, "some text"&lf);
 file_close(output);

 <B>file</B> test_data : word_file;
 file_open(test_data, "test1.dat", read_mode);
 read(test_data, word_value);


</PRE>

<H3><a name="sutype"> subtype declaration </a></H3>
<PRE>
Declare a type that is a subtype of an existing type.
Note that <B>type</B> creates a new type while <B>subtype</B>
creates a type that is a constraint of an existing type.

 <B>subtype</B> identifier <B>is</B> subtype_indication ;

 <B>subtype</B> name_type <B>is</B> string(1 to 20) ;
 <B>variable</B> a_name : name_type := "Doe, John           ";

 <B>subtype</B> small_int <B>is</B> integer range 0 to 10 ;
 <B>variable</B> little : small_int := 4;

 <B>subtype</B> word <B>is</B> std_logic_vector(31 downto 0) ;
 <B>signal</B> my_word : word := x"FFFFFFFC";

</PRE>

<H3><a name="cobj"> constant, object declaration </a></H3>
<PRE>
Used to have an identifier name for a constant value.
The value can not be changed by any executable code.

  <B>constant</B> identifier : subtype_indication := constant_expression;

  <B>constant</B> Pi : real := 3.14159;
  <B>constant</B> Half_Pi : real := Pi/2.0;
  <B>constant</B> cycle_time : time := 2 ns;
  <B>constant</B> N, N5 : integer := 5;

A deferred constant has no  := constant_expression  can only be used
in a package declaration and a value must appear in the package body.

</PRE>

<H3><a name="sobj"> signal, object declaration </a></H3>
<PRE>
Used to define an identifier as a signal object.
No explicit initialization of an object of type T causes the default
initialization at time zero to be the value of T'left

 <B>signal</B> identifier : subtype_indication [ signal_kind ] [ := expression ];

 <B>signal</B> a_bit : bit := '0';
 a_bit <= b_bit <B>xor</B> '1';    -- concurrent assignment

 <B>signal</B> my_word : word := X"01234567";
 my_word <= X"FFFFFFFF";           -- concurrent assignment

 <B>signal</B> foo : word <B>register</B>; -- guarded signal
 <B>signal</B> bar : word <B>bus</B>;      -- guarded signal
 <B>signal</B> join : word  wired_or; -- wired_or must be a resolution function

signal_kind may be <B>register</B>  or  <B>bus</B>.

A simple signal of an unresolved type can have only one driver.
Note that "bit" is an unresolved type as is "std_ulogic", but,
"std_logic" is a resolved type and allows multiple drivers of a
simple signal.
</PRE>


<H3><a name="vobj"> variable, object declaration </a></H3>
<PRE>
Used to define an identifier as a variable object.
No explicit initialization of an object of type T causes the default
initialization at time zero to be the value of T'left

 <B>variable</B> identifier : subtype_indication [ := expression ];

 <B>variable</B> count : integer := 0;
 count := count + 1;

A variable may be declared as shared and used by more than one process,
with the restriction that only one process may access the variable
in a single simulation cycle.

 <B>shared variable</B> identifier : subtype_indication [ := expression ];

 <B>shared variable</B> status : status_type := stop;
 status := start;

Note: Variables declared in subprograms and processes
      must not be declared shared.
      Variables declared in entities, architectures, packages and blocks
      must be declared shared.
      Some analysers/compilers may require shared variables
      to be 'protected'.

Note: Both <B>signal</B> and <B>variable</B> use  :=  for initialization.
      <B>signal</B>   uses  <=  for concurrent assignment
      <B>variable</B> uses  :=  for sequential assignment
</PRE>

<H3><a name="fobj"> file, object declaration </a></H3>
<PRE>
Used to define an identifier as a file object.

  <B>file</B> identifier : subtype_indication [ file_open_information ]

  file_open_information
  [ <B>open</B> file_open_kind ] <B>is</B> file_logical_name

  file_open_kind   from  <B>use</B> STD.textio.all
    read_mode
    write_mode
    append_mode

  <B>use</B> STD.textio.all; -- declares types 'text' and 'line'
  <B>file</B> my_file : text <B>open</B> write_mode <B>is</B> "file5.dat";
  <B>variable</B> my_line : line;

  write(my_line, string'("Hello."); -- build a line
  writeline(my_file, my_line);      -- write the line to a file

  Note: The file_logical_name is a string in quotes and its
        syntax must conform to the operating system where
        the VHDL will be simulated. The old DOS 8.3 format
        in lower case works on almost all operating systems.

</PRE>

<H3><a name="alias"> alias declarations </a></H3>
<PRE>
Used to declare an additional name for an existing name.

  <B>alias</B> new_name <B>is</B> existing_name_of_same_type ;
  <B>alias</B> new_name [ : subtype_indication ] : <B>is</B> [ signature ];

    new_name may be an indentifier, a character literal or operator symbol

  <B>alias</B> rs <B>is</B> my_reset_signal ; -- bad use of alias
  <B>alias</B> mantissa:std_logic_vector(23 downto 0) <B>is</B> my_real(8 to 31);
  <B>alias</B> exponent <B>is</B> my_real(0 to 7);
  <B>alias</B> "<" <B>is</B> my_compare [ my_type, my_type, <B>return</B> boolean ] ;
  <B>alias</B> 'H' <B>is</B> STD.standard.bit.'1' [ <B>return</B> bit ] ;

</PRE>

<H3><a name="attrd"> attribute declaration </a></H3>
<PRE>
Users may define attributes to be used in a local scope.
Predefined attributes are in the <a href="attribute.html">Predefined Attributes section</a>

  <B>attribute</B> identifier : type_mark ;

  <B>attribute</B> enum_encoding : string; -- user defined
  <B>type</B> my_state <B>is</B> (start, stop, ready, off, warmup);
  <B>attribute</B> enum_encoding <B>of</B> my_state : <B>type</B> <B>is</B> "001 010 011 100 111";
  <B>signal</B> my_status : my_state := off; -- value "100"

</PRE>

<H3><a name="attrs"> attribute specification </a></H3>
<PRE>
Used to associate expressions with attributes.
Predefined attributes are in the <a href="attribute.html">Predefined Attributes section</a>

  <B>attribute</B> identifier <B>of</B> name : entity_class <B>is</B> expression ;

  
  entity_class
    <B>architecture</B>  <B>component</B>  <B>configuration</B>  <B>constant</B>
    <B>entity</B>        <B>file</B>       <B>function</B>       <B>group</B>
    <B>label</B>         <B>literal</B>    <B>package</B>        <B>procedure</B>
    <B>signal</B>        <B>subtype</B>    <B>type</B>           <B>variable</B>
    <B>units</B>

  <B>attribute</B> enum_encoding : string;
  <B>type</B> my_state <B>is</B> (start, stop, ready, off, warmup);
  <B>attribute</B> enum_encoding <B>of</B> my_state : <B>type</B> <B>is</B> "001 010 011 100 111";
  <B>signal</B> my_status : my_state := off; -- value "100"

</PRE>

<H3><a name="comp"> component declaration </a></H3>
<PRE>
Used to define a component interface. Typically placed in an architecture
or package declaration. The component or instances of the component are
related to a design entity in a library in a configuration.

  <B>component</B> component_name <B>is</B>
     <B>generic</B> ( generic_variable_declarations ) ; -- optional
     <B>port</B> ( input_and_output_variable_declarations ) ;
  <B>end</B> <B>component</B> component_name ;

  generic_variable_declarations are of the form:
     variable_name : variable_type := value ;

  input_and_output_variable_declaration are of the form:
     variable_name : port_mode  variable_type ;
  port_mode may be <B>in</B> <B>out</B> <B>inout</B> <B>buffer</B> <B>linkage</B>

  <B>component</B> reg32 <B>is</B>
     <B>generic</B> ( setup_time : time := 50 ps;
               pulse_width : time := 100 ps  );
     <B>port</B> ( input : <B>in</B> std_logic_vector(31 downto 0);
            output: <B>out</B> std_logic_vector(31 downto 0);
            Load  : <B>in</B>  std_logic_vector;
            Clk   : <B>in</B>  std_logic_vector );
  <B>end</B> <B>component</B> reg32;

Then an instantiation of the reg32 component in an architecture might be:

  RegA : reg32 <B>generic</B> <B>map</B> ( setup_time => global_setup,
                             pulse_width => 150 ps) -- no semicolon
               <B>port</B> <B>map</B> ( input => Ainput,
                          output => Aoutput,
                          Load => Aload,
                          Clk => Clk );

An alternative to the component declaration and corresponding
component instantiation above is to use a design entity instantiation.

  RegA : <B>entity</B> WORK.reg32(behavior) -- library.entity(architecture)
               <B>generic</B> <B>map</B> ( global_setup, 150 ps) -- no semicolon
               <B>port</B> <B>map</B> ( Ainput, Aoutput, Aload, Clk );


There is no requirement that the component name be the same as
the design entity name that the component represents. Yet, the
component name and design entity name are often the same because
some systems automatically take the most recently compiled
architecture of a library entity with the same name as the
component name.
 
</PRE>

<H3><a name="groupt"> group template declaration </a></H3>
<PRE>
A group template declaration declares a group template, which defines
the allowable classes of named entities that can appear in a group.

  <B>group</B> identifier <B>is</B> ( entity_class_list ) ;

  entity_class_list
     entity_class [, entity_class ] [ &lt;&gt; ]
  
  entity_class
    <B>architecture</B>  <B>component</B>  <B>configuration</B>  <B>constant</B>
    <B>entity</B>        <B>file</B>       <B>function</B>       <B>group</B>
    <B>label</B>         <B>literal</B>    <B>package</B>        <B>procedure</B>
    <B>signal</B>        <B>subtype</B>    <B>type</B>           <B>variable</B>
    <B>units</B>

  -- a group of any number of labels
  <B>group</B> my_stuff <B>is</B> ( <B>label</B> <> ) ;


</PRE>

<H3><a name="group"> group declaration </a></H3>
<PRE>
A group declaration declares a group, a named collection of named entities.

  <B>group</B> identifier : group_template_name ( group_member [, group member] ) ;

  <B>group</B> my_group : my_stuff ( lab1, lab2, lab3 ) ;
 
</PRE>

<H3><a name="disco"> disconnect specification </a></H3>
<PRE>

A disconnect specification applies to a null transaction such as
a guard becoming false.

 <B>disconnect</B> signal_name : type_mark <B>after</B> time_expression ;
 <B>disconnect</B> <B>others</B> : type_mark <B>after</B> time_expression ;
 <B>disconnect</B> <B>all</B> : type_mark <B>after</B> time_expression ;

 <B>disconnect</B> my_sig : std_logic <B>after</B> 3 ns;

</PRE>


<H2> VHDL Resolution and Signatures </H2>

<H3> Contents</H3>
<dir>
  <LI><a href="summary_one.html#resf"> Resolution Functions </a>
  <LI><a href="summary_one.html#sign"> Signatures </a>
  <LI><a href="summary_one.html#attr"> 'left 'right vs 'high 'low </a>
</dir>

<H3><a name="resf"> Resolution Functions </a></H3>
<PRE>
A resolution function defines how values from multiple sources,
multiple drivers, are resolved into a single value.

A type may be defined to have a resolution function. Every signal
object of this type uses the resolution function when there are
multiple drivers.

A signal may be defined to use a specific resolution function.
This signal uses the resolution function when there are multiple
drivers.

A resolution function must be a pure function that has a single
input parameter of class <B>constant</B> that is a one dimensional
unconstrained array of the type of the resolved signal.

An example is from the package  std_logic_1164 :


    <B>type</B> std_ulogic <B>is</B> ( 'U',  -- Uninitialized
                         'X',  -- Forcing  Unknown
                         '0',  -- Forcing  0
                         '1',  -- Forcing  1
                         'Z',  -- High Impedance   
                         'W',  -- Weak     Unknown
                         'L',  -- Weak     0       
                         'H',  -- Weak     1       
                         '-'   -- Don't care
                       );

    <B>type</B> std_ulogic_vector <B>is</B> <B>array</B> ( natural <B>range</B> &lt;&gt; ) <B>of</B> std_ulogic;
                                    

    -- resolution function

    <B>function</B> resolved ( s : std_ulogic_vector ) <B>return</B> std_ulogic;
        <B>variable</B> result : std_ulogic := 'Z';  -- weakest state default
    <B>begin</B>
        -- the test for a single driver is essential otherwise the
        -- loop would return 'X' for a single driver of '-' and that
        -- would conflict with the value of a single driver unresolved
        -- signal.
        <B>if</B>  s'length = 1 <B>then</B>
            <B>return</B> s(s'low);
        <B>else</B>
            <B>for</B> i <B>in</B> s'range <B>loop</B>
                result := resolution_table(result, s(i));
            <B>end</B> <B>loop</B>;
        <B>end</B> <B>if</B>;
        <B>return</B> result;
    <B>end</B> resolved;


    <B>constant</B> resolution_table : stdlogic_table := (
    --      ---------------------------------------------------------
    --      |  U    X    0    1    Z    W    L    H    -        |   |  
    --      ---------------------------------------------------------
            ( 'U', 'U', 'U', 'U', 'U', 'U', 'U', 'U', 'U' ), -- | U |
            ( 'U', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X' ), -- | X |
            ( 'U', 'X', '0', 'X', '0', '0', '0', '0', 'X' ), -- | 0 |
            ( 'U', 'X', 'X', '1', '1', '1', '1', '1', 'X' ), -- | 1 |
            ( 'U', 'X', '0', '1', 'Z', 'W', 'L', 'H', 'X' ), -- | Z |
            ( 'U', 'X', '0', '1', 'W', 'W', 'W', 'W', 'X' ), -- | W |
            ( 'U', 'X', '0', '1', 'L', 'W', 'L', 'W', 'X' ), -- | L |
            ( 'U', 'X', '0', '1', 'H', 'W', 'W', 'H', 'X' ), -- | H |
            ( 'U', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X' )  -- | - |
        );

    
    <B>subtype</B> std_logic <B>is</B> resolved std_ulogic;


    <B>type</B> std_logic_vector <B>is</B> <B>array</B> ( natural <B>range</B> &lt;&gt;) <B>of</B> std_logic;

    <B>signal</B> xyz : std_logic_vector(0 <B>to</B> 3);

    xyz <= -- some expression ;

    xyz <= -- some other expression ; -- a second driver
                           -- each bit of  xyz  comes from function "resolved"

</PRE>

<H3><a name="sign"> Signatures </a></H3>
<PRE>
A signature distinguishes between overloaded subprograms and enumeration
literals based on their parameter and result type profiles.
A signature may be used in an attribute name, entity designator,
or alias declaration.

The syntax of the signature is

  [ type_mark, type_mark, ... , type_mark <B>return</B> type_mark ]

A signature used in an alias statement to give a shorthand to
a textio procedure is:

    <B>alias</B> swrite <B>is</B> write [line, string, side, width] ;

allowing   swrite(output, "some text");  in place of
           write(output, string'("some text"));

The "[line, string, side, width]" is the signature to choose which
of the overloaded  'write'  procedures to alias to 'swrite'.

No <B>return</B> is used for procedures.
The type marks are the parameter types in their defined order.
The square brackets at beginning and end are part of the signature.
The signature is used immediately after the subprogram or
enumeration literal name.

</PRE>

<H3><a name="attr">  'left 'right vs 'high 'low  </a></H3>
<PRE>
This is just a specific example to help understand '<B>to</B>' vs '<B>downto</B>'
and how the values of attributes such as 'left 'right and 'high 'low
are determined.

A : std_logic_vector(31 <B>downto</B> 0) := x"FEDCBA98"; -- '<B>downto</B>'
B : std_logic_vector( 4 <B>to</B>    27) := x"654321";   -- '<B>to</B>'
C       a literal constant                  x"321"

Name  bitstring (attributes on following lines)

 A    11111110110111001011101010011000
      A'left=31     A'right=0      A'low=0      A'high=31
      A(A'left)=1   A(A'right)=0   A(A'low)=0   A(A'high)=1
      A'range=(31 downto 0)        A'reverse_range=(0 to 31) 
      A'length=32                  A'ascending=false

 B    011001010100001100100001                  B'ascending=true
      B'left=4      B'right=27     B'low=4      B'high=27
      B(B'left)=0   B(B'right)=1   B(B'low)=0   B(B'high)=1
      B'range=(4 to 27)            B'reverse_range=(27 downto 4) 
      B'length=24                  B'ascending=true

 C    001100100001
      C'left=0      C'right=11     C'low=0      C'high=11
      C(C'left)=0   C(C'right)=1   C(C'low)=0   C(C'high)=1
      C'range=(0 to 11)            C'reverse_range=(11 downto 0) 
      C'length=12                  C'ascending=true

      Notice the default values of attributes on literal constants.
      Always a range of (0 to 'length-1)  'left  = 'low  = 0
                                          'right = 'high = 'length-1
</PRE>






<H2> VHDL Reserved Words </H2>
<PRE>
<B>abs</B>           operator, absolute value of right operand. No () needed.
<B>access</B>        used to define an access type, pointer
<B>after</B>         specifies a time after NOW
<B>alias</B>         create another name for an existing identifier
<B>all</B>           dereferences what precedes the .all
<B>and</B>           operator, logical "and" of left and right operands
<B>architecture</B>  a secondary design unit
<B>array</B>         used to define an array, vector or matrix
<B>assert</B>        used to have a program check on itself
<B>attribute</B>     used to declare attribute functions
<B>begin</B>         start of a  <B>begin</B>  <B>end</B>  pair
<B>block</B>         start of a block structure
<B>body</B>          designates a procedure body rather than declaration
<B>buffer</B>        a mode of a signal, holds a value
<B>bus</B>           a mode of a signal, can have multiple drivers
<B>case</B>          part of a case statement
<B>component</B>     starts the definition of a component
<B>configuration</B> a primary design unit
<B>constant</B>      declares an identifier to be read only
<B>disconnect</B>    signal driver condition
<B>downto</B>        middle of a range  31 downto 0
<B>else</B>          part of "if" statement, if cond then ... else ... end if;
<B>elsif</B>         part of "if" statement, if cond then ... elsif cond ...
<B>end</B>           part of many statements, may be followed by word and id
<B>entity</B>        a primary design unit
<B>exit</B>          sequential statement, used in loops
<B>file</B>          used to declare a file type
<B>for</B>           start of a for type loop statement
<B>function</B>      starts declaration and body of a function
<B>generate</B>      make copies, possibly using a parameter
<B>generic</B>       introduces generic part of a declaration
<B>group</B>         collection of types that can get an attribute
<B>guarded</B>       causes a wait until a signal changes from False to True
<B>if</B>            used in "if" statements
<B>impure</B>        an impure function is assumed to have side effects
<B>in</B>            indicates a parameter in only input, not changed
<B>inertial</B>      signal characteristic, holds a value
<B>inout</B>         indicates a parameter is used and computed in and out
<B>is</B>            used as a connective in various statements
<B>label</B>         used in attribute statement as entity specification
<B>library</B>       context clause, designates a simple library name
<B>linkage</B>       a mode for a port, used like <B>buffer</B> and <B>inout</B>
<B>literal</B>       used in attribute statement as entity specification
<B>loop</B>          sequential statement, loop ... end loop;
<B>map</B>           used to map actual parameters, as in  port map
<B>mod</B>           operator, left operand modulo right operand
<B>nand</B>          operator, "nand" of left and right operands
<B>new</B>           allocates memory and returns access pointer
<B>next</B>          sequential statement, used in loops
<B>nor</B>           operator, "nor" of left and right operands
<B>not</B>           operator, complement of right operand
<B>null</B>          sequential statement and a value
<B>of</B>            used in type declarations, <B>of</B> Real ;
<B>on</B>            used as a connective in various statements
<B>open</B>          initial file characteristic
<B>or</B>            operator, logical "or" of left and right operands
<B>others</B>        fill in missing, possibly all, data
<B>out</B>           indicates a parameter is computed and output
<B>package</B>       a design unit, also  package body
<B>port</B>          interface definition, also  port map
<B>postponed</B>     make process wait for all non postponed process to suspend
<B>procedure</B>     typical programming procedure
<B>process</B>       sequential or concurrent code to be executed
<B>pure</B>          a pure function may not have side effects
<B>range</B>         used in type definitions, <B>range</B> 1 <B>to</B> 10;
<B>record</B>        used to define a new record type
<B>register</B>      signal parameter modifier
<B>reject</B>        clause in delay mechanism, followed be a time
<B>rem</B>           operator, remainder of left operand divided by right op
<B>report</B>        statement and clause in assert statement, string output
<B>return</B>        statement in procedure or function
<B>rol</B>           operator, left operand rotated left by right operand
<B>ror</B>           operator, left operand rotated right by right operand
<B>select</B>        used in selected signal assignment statement
<B>severity</B>      used in assertion and reporting, followed by a severity
<B>signal</B>        declaration that an object is a signal
<B>shared</B>        used to declare shared objects
<B>sla</B>           operator, left operand shifted left arithmetic by right op
<B>sll</B>           operator, left operand shifted left logical by right op
<B>sra</B>           operator, left operand shifted right arithmetic by right
<B>srl</B>           operator, left operand shifted right logical by right op
<B>subtype</B>       declaration to restrict an existing type
<B>then</B>          part of  if condition then ...
<B>to</B>            middle of a range  1 to 10
<B>transport</B>     signal characteristic
<B>type</B>          declaration to create a new type
<B>unaffected</B>    used in signal waveform
<B>units</B>         used to define new types of units
<B>until</B>         used in wait statement
<B>use</B>           make a package available to this design unit
<B>variable</B>      declaration that an object is a variable
<B>wait</B>          sequential statement, also used in case statement
<B>when</B>          used for choices in case and other statements
<B>while</B>         kind of loop statement
<B>with</B>          used in selected signal assignment statement          
<B>xnor</B>          operator, exclusive "nor" of left and right operands
<B>xor</B>           operator, exclusive "or" of left and right operands

</PRE>

<H2> VHDL Operators </H2>
<H3><PRE>
   Highest precedence first,
   left to right within same precedence group,
   use parenthesis to control order.
   Unary operators take an operand on the right.
   "result same" means the result is the same as the right operand.
   Binary operators take an operand on the left and right.
   "result same" means the result is the same as the left operand.
</PRE></H3>

<PRE>
<B>**  </B> exponentiation,  numeric <B>**</B> integer,  result numeric
<B>abs </B> absolute value,  <B>abs</B> numeric,  result numeric
<B>not </B> complement,      <B>not</B> logic or boolean,  result same

<B>*   </B> multiplication,  numeric <B>*</B> numeric,  result numeric
<B>/   </B> division,        numeric <B>/</B> numeric,  result numeric
<B>mod </B> modulo,          integer <B>mod</B> integer,  result integer
<B>rem </B> remainder,       integer <B>rem</B> integer,  result integer

<B>+   </B> unary plus,      <B>+</B> numeric,  result numeric
<B>-   </B> unary minus,     <B>-</B> numeric,  result numeric

<B>+   </B> addition,        numeric <B>+</B> numeric,  result numeric
<B>-   </B> subtraction,     numeric <B>-</B> numeric,  result numeric
<B>&   </B> concatenation,   array or element <B>&</B> array or element,
                        result array

<B>sll </B> shift left logical,     logical array <B>sll</B> integer,  result same
<B>srl </B> shift right logical,    logical array <B>srl</B> integer,  result same
<B>sla </B> shift left arithmetic,  logical array <B>sla</B> integer,  result same
<B>sra </B> shift right arithmetic, logical array <B>sra</B> integer,  result same
<B>rol </B> rotate left,            logical array <B>rol</B> integer,  result same
<B>ror </B> rotate right,           logical array <B>ror</B> integer,  result same

<B>=   </B> test for equality, result is boolean
<B>/=  </B> test for inequality, result is boolean
<B>&lt;   </B> test for less than, result is boolean
<B>&lt;=  </B> test for less than or equal, result is boolean
<B>&gt;   </B> test for greater than, result is boolean
<B>&gt;=  </B> test for greater than or equal, result is boolean

<B>and </B> logical and,                logical array or boolean,  result is same
<B>or  </B> logical or,                 logical array or boolean,  result is same
<B>nand</B> logical complement of and,  logical array or boolean,  result is same
<B>nor </B> logical complement of or,   logical array or boolean,  result is same
<B>xor </B> logical exclusive or,       logical array or boolean,  result is same
<B>xnor</B> logical complement of exclusive or,  logical array or boolean,  result is same

</PRE>





<H2> VHDL Predefined Attributes </H2>
<PRE>
 The syntax of an attribute is some named entity followed
 by an apostrophe and one of the following attribute names.
 A parameter list is used with some attributes.
 Generally: T represents any type, A represents any array 
 or constrained array type, S represents any signal and
 E represents a named entity.

</PRE>

<PRE>

T'BASE       is the base type of the type T
T'LEFT       is the leftmost value of type T. (Largest if downto)
T'RIGHT      is the rightmost value of type T. (Smallest if downto)
T'HIGH       is the highest value of type T.
T'LOW        is the lowest value of type T.
T'ASCENDING  is boolean true if range of T defined with <B>to</B> .
T'IMAGE(X)   is a string representation of X that is of type T.
T'VALUE(X)   is a value of type T converted from the string X.
T'POS(X)     is the integer position of X in the discrete type T.
T'VAL(X)     is the value of discrete type T at integer position X.
T'SUCC(X)    is the value of discrete type T that is the successor of X.
T'PRED(X)    is the value of discrete type T that is the predecessor of X.
T'LEFTOF(X)  is the value of discrete type T that is left of X.
T'RIGHTOF(X) is the value of discrete type T that is right of X.
A'LEFT       is the leftmost subscript of array A or constrained array type.
A'LEFT(N)    is the leftmost subscript of dimension N of array A.
A'RIGHT      is the rightmost subscript of array A or constrained array type.
A'RIGHT(N)   is the rightmost subscript of dimension N of array A.
A'HIGH       is the highest subscript of array A or constrained array type.
A'HIGH(N)    is the highest subscript of dimension N of array A.
A'LOW        is the lowest subscript of array A or constrained array type.
A'LOW(N)     is the lowest subscript of dimension N of array A.
A'RANGE      is the range  A'LEFT <B>to</B> A'RIGHT  or  A'LEFT <B>downto</B> A'RIGHT .
A'RANGE(N)   is the range of dimension N of A.
A'REVERSE_RANGE  is the range of A with <B>to</B> and <B>downto</B> reversed.
A'REVERSE_RANGE(N)  is the REVERSE_RANGE of dimension N of array A.
A'LENGTH     is the integer value of the number of elements in array A.
A'LENGTH(N)  is the number of elements of dimension N of array A.
A'ASCENDING  is boolean <B>true</B> if range of A defined with <B>to</B> .
A'ASCENDING(N)  is boolean <B>true</B> if dimension N of array A defined with <B>to</B> .
S'DELAYED(t) is the signal value of S at time now - t .
S'STABLE     is true if no event is occurring on signal S.
S'STABLE(t)  is true if no even has occurred on signal S for t units of time.
S'QUIET      is true if signal S is quiet. (no event this simulation cycle)
S'QUIET(t)   is true if signal S has been quiet for t units of time.
S'TRANSACTION  is a bit signal, the inverse of previous value each cycle S is active.
S'EVENT      is true if signal S has had an event this simulation cycle.
S'ACTIVE     is true if signal S is active during current simulation cycle.
S'LAST_EVENT is the time since the last event on signal S.
S'LAST_ACTIVE  is the time since signal S was last active.
S'LAST_VALUE is the previous value of signal S.
S'DRIVING    is false only if the current driver of S is a null transaction.
S'DRIVING_VALUE  is the current driving value of signal S.
E'SIMPLE_NAME  is a string containing the name of entity E.
E'INSTANCE_NAME  is a string containing the design hierarchy including E.
E'PATH_NAME  is a string containing the design hierarchy of E to design root.

</PRE>


<H2> Standard VHDL Packages </H2>


<H3><a name="pkg"> VHDL standard packages and types </a></H3>
<PRE>
  The following packages should be installed along with the VHDL
  compiler and simulator.  The packages that you need,
  except for "standard", must be specifically accessed by each of
  your source files with statements such as:

        <B>library</B> IEEE;
        <B>use</B> IEEE.std_logic_1164.<B>all</B>;
        <B>use</B> IEEE.std_logic_textio.<B>all</B>;
        <B>use</B> IEEE.std_logic_arith.<B>all</B>;
        <B>use</B> IEEE.numeric_bit.<B>all</B>;
        <B>use</B> IEEE.numeric_std.<B>all</B>;
        <B>use</B> IEEE.std_logic_signed.<B>all</B>;
        <B>use</B> IEEE.std_logic_unsigned.<B>all</B>;
        <B>use</B> IEEE.math_real.<B>all</B>;
        <B>use</B> IEEE.math_complex.<B>all</B>;

        library STD;
        use STD.textio;

  A version of these packages, declaration and body, are in
  <a href="packages/index.html">this directory</a>

The package <a href="standard.vhdl.txt"> standard </a> is predefined in the compiler.
  Types defined include:  bit      bit_vector             typical signals
                          integer  natural  positive      typical variables
                          boolean  string   character     typical variables
                          real     time     delay_length  typical variables
  Click on <a href="standard.vhdl.txt">standard</a> to see the functions defined
  Note: This package must be provided with compiler, do not use this one.


The package <a href="textio.vhdl.txt"> textio </a> provides user input/output
  Types defined include:     line       text   side    width
  Functions defined include: readline   read
                             writeline  write  endline
  Click on <a href="textio.vhdl.txt">textio</a> to see how to call the functions


The package <a href="packages/std_logic_1164.vhd.txt"> std_logic_1164 </a> provides enhanced signal types
  Types defined include:   std_ulogic   std_ulogic_vector
                           std_logic    std_logic_vector
  Click on <a href="std_logic_1164.vhdl.txt">std_logic_1164</a> to see available functions


The package <a href="packages/std_logic_textio.vhd.txt"> std_logic_textio </a> provides input/output for 1164 types
  Functions defined include: readline   read
                             writeline  write  endline
  Click on <a href="std_logic_textio.vhdl.txt">std_logic_textio</a> to see how to call the functions


The package <a href="packages/std_logic_arith_syn.vhd.txt"> std_logic_arith </a> provides numerical computation
  This package name unfortunately seams to have several definitions:

  <a href="packages/std_logic_arith_syn.vhd.txt">std_logic_arith_syn.vhd</a>
  defines types  signed  and  unsigned  and
  has arithmetic functions that operate on signal types
  signed  and  unsigned  and  std_logic_vector  and  std_ulogic_vector,
  but adding  A to B of std_logic_vector type, needs  
  unsigned(A) + unsigned(B).
  Click on <a href="std_logic_arith_syn.vhdl.txt">std_logic_arith_syn</a> to see the functions defined

  <a href="packages/std_logic_arith_ex.vhd.txt">std_logic_arith_ex.vhd</a>
  has arithmetic functions that operate on signal types
  std_logic_vector  and  std_ulogic_vector
  Click on <a href="std_logic_arith_ex.vhdl.txt">std_logic_arith_ex</a> to see the functions defined


The package <a href="packages/numeric_bit.vhd.txt"> numeric_bit </a> provides numerical computation
  Types defined include:  unsigned  signed   arrays of type bit for signals
  Click on <a href="numeric_bit.vhdl.txt">numeric_bit</a> to see the functions defined


The package <a href="packages/numeric_std.vhd.txt"> numeric_std </a> provides numerical computation
  Types defined include: unsigned  signed  arrays of type std_logic for signals
  Click on <a href="numeric_std.vhdl.txt">numeric_std</a> to see the functions defined


The package <a href="packages/std_logic_signed.vhd.txt"> std_logic_signed </a> provides signed numerical computation
  on type std_logic_vector

  Click on <a href="std_logic_signed.vhdl.txt">std_logic_signed</a> to see the functions defined


The package <a href="packages/std_logic_unsigned.vhd.txt"> std_logic_unsigned </a> provides unsigned numerical computation
  on type std_logic_vector
  Click on <a href="std_logic_unsigned.vhdl.txt">std_logic_unsigned</a> to see the functions defined


The package <a href="packages/mathpack.vhd.txt"> math_real </a> provides numerical computation
  on type real

  Click on <a href="math_real.vhdl.txt">math_real</a> to see the functions defined
  This declaration and body are in <a href="packages/mathpack.vhd.txt">mathpack</a>

The package <a href="packages/mathpack.vhd.txt"> math_complex </a> provides numerical computation
  Types defined include: complex, complex_vector, complex_polar

  Click on <a href="math_complex.vhdl.txt">math_complex</a> to see the functions defined
  This declaration and body are in <a href="packages/mathpack.vhd.txt">mathpack</a>


</PRE>


<H3><a name="Other"> Other Links </a></H3>
<UL>
  <LI> <a href="index.shtml">
       VHDL help page
       </a>
  <LI> <a href="samples/samples.shtml">
       Lots of sample VHDL code, from very simple, through I/O, to complex
       </a>
  <LI> <a href="http://tech-www.informatik.uni-hamburg.de/vhdl">
       Hamburg VHDL Archive (the best set of links I have seen!)
       </a>
  <LI> <a href="http://rassp.scra.org/vhdl/tools/tools.html">
       RASSP Project VHDL Tools
       </a>
  <LI> <a href="http://www.vhdl.org">
       VHDL Organization Home Page
       </a>
  <LI> <a href="http://www.freehdl.seul.org">
       gnu GPL VHDL for Linux, under development
       </a>
  <LI> <a href="http://www.ftlsys.com">
       More information on Exploration/VHDL from FTL Systems.
       </a>
</UL>

<H4><a href="summary_one.html#Top"> Go to top </a></H4>
<H4><a href="index.shtml"> Go to VHDL index </a></H4>
</BODY>
</HTML>



